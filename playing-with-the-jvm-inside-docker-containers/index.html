<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Playing with the JVM inside Docker Containers | Nebrass Homepage</title><meta name=keywords content><meta name=description content="Nowadays, the most of the Java microservices and even many Java application are packaged and deployed as Docker containers. Everyone is enjoying (I hope üòÜ) the Docker experience, compared to the traditional VMs.¬†But, the Docker containerization will not come alone.. nothing is autonomous üòÅ So, there are many concerns to take into consideration while containerizing Java applications, like playing with the JVM.
The Docker racing was accelerated by the presence of Kubernetes in the market, which is coming with an amazing set of great features."><meta name=author content><link rel=canonical href=https://blog.nebrass.fr/playing-with-the-jvm-inside-docker-containers/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9aeab43847eb11aca320bfadedfe191ed6516dd768bf1314b534c4992aac901a.css integrity="sha256-muq0OEfrEayjIL+t7f4ZHtZRbddovxMUtTTEmSqskBo=" rel="preload stylesheet" as=style><script src=/js/prism.min.js></script>
<link rel=stylesheet href=/css/prism.min.css><link rel=icon href=https://blog.nebrass.fr/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.nebrass.fr/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.nebrass.fr/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.nebrass.fr/apple-touch-icon.png><link rel=mask-icon href=https://blog.nebrass.fr/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style amp-custom>.main,.footer,.nav{max-width:calc(var(--main-width) + var(--gap) * 15)}</style><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-111781986-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Playing with the JVM inside Docker Containers"><meta property="og:description" content="Nowadays, the most of the Java microservices and even many Java application are packaged and deployed as Docker containers. Everyone is enjoying (I hope üòÜ) the Docker experience, compared to the traditional VMs.¬†But, the Docker containerization will not come alone.. nothing is autonomous üòÅ So, there are many concerns to take into consideration while containerizing Java applications, like playing with the JVM.
The Docker racing was accelerated by the presence of Kubernetes in the market, which is coming with an amazing set of great features."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.nebrass.fr/playing-with-the-jvm-inside-docker-containers/"><meta property="og:image" content="https://blog.nebrass.fr/images/playing-jvm-inside-containers.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-03T00:00:00+00:00"><meta property="article:modified_time" content="2019-12-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nebrass.fr/images/playing-jvm-inside-containers.webp"><meta name=twitter:title content="Playing with the JVM inside Docker Containers"><meta name=twitter:description content="Nowadays, the most of the Java microservices and even many Java application are packaged and deployed as Docker containers. Everyone is enjoying (I hope üòÜ) the Docker experience, compared to the traditional VMs.¬†But, the Docker containerization will not come alone.. nothing is autonomous üòÅ So, there are many concerns to take into consideration while containerizing Java applications, like playing with the JVM.
The Docker racing was accelerated by the presence of Kubernetes in the market, which is coming with an amazing set of great features."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.nebrass.fr/posts/"},{"@type":"ListItem","position":3,"name":"Playing with the JVM inside Docker Containers","item":"https://blog.nebrass.fr/playing-with-the-jvm-inside-docker-containers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Playing with the JVM inside Docker Containers","name":"Playing with the JVM inside Docker Containers","description":"Nowadays, the most of the Java microservices and even many Java application are packaged and deployed as Docker containers. Everyone is enjoying (I hope üòÜ) the Docker experience, compared to the traditional VMs.¬†But, the Docker containerization will not come alone.. nothing is autonomous üòÅ So, there are many concerns to take into consideration while containerizing Java applications, like playing with the JVM.\nThe Docker racing was accelerated by the presence of Kubernetes in the market, which is coming with an amazing set of great features.","keywords":[],"articleBody":"Nowadays, the most of the Java microservices and even many Java application are packaged and deployed as Docker containers. Everyone is enjoying (I hope üòÜ) the Docker experience, compared to the traditional VMs.¬†But, the Docker containerization will not come alone.. nothing is autonomous üòÅ So, there are many concerns to take into consideration while containerizing Java applications, like playing with the JVM.\nThe Docker racing was accelerated by the presence of Kubernetes in the market, which is coming with an amazing set of great features.\nOne of the great features available for handling the containers is having the option to control the resources allocated for a Pod üòÜ for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  apiVersion:v1kind:Podmetadata:name:frontendspec:containers:- name:dbimage:mysqlenv:- name:MYSQL_ROOT_PASSWORDvalue:\"password\"resources:requests:memory:\"64Mi\"cpu:\"250m\"limits:memory:\"128Mi\"cpu:\"500m\"- name:wpimage:wordpressresources:requests:memory:\"64Mi\"cpu:\"250m\"limits:memory:\"128Mi\"cpu:\"500m\"  This yaml resource descriptor will define CPU and Memory limits for the two containers running in this frontend Pod. These limits was not recognized by the JVM under Java versions until 9 üò≠üò≠With the appearance of the Java 10, the JVM can now be aware of these limits. ü•≥\nThis great support was even ported to the JDK 8 update 191.\nwhat are these great Improvements for Docker Containers ? We can quickly start testing the awareness of the JVM under Java 10 of the Container limits that we can put:\nLet‚Äôs create a Docker container without any limits. In the created container, we will be running the JShell to test what information do we have in the Runtime?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ docker container run -it openjdk:10-jdk Dec 02, 2019 8:14:54 AM java.util.prefs.FileSystemPreferences$1 run INFO: Created user preferences directory. | Welcome to JShell -- Version 10.0.2 | For an introduction type: /help intro jshell Runtime.getRuntime().totalMemory() $1 == 33554432 jshell Runtime.getRuntime().maxMemory() $2 == 524288000 jshell Runtime.getRuntime().availableProcessors() $3 == 8   Before digging into the returned values, what are these methods ?\nBased on the Javadoc of the Runtime class:\n totalMemory() Gives the total amount of memory in the Java virtual machine. The value returned by this method may vary over time, depending on the host environment. Note that the amount of memory required to hold an object of any given type may be implementation-dependent. Returns: the total amount of memory currently available for current and future objects, measured in bytes. maxMemory() Gives the maximum amount of memory that the Java virtual machine will attempt to use. If there is no inherent limit then the value Long.MAX_VALUE will be returned. Returns: the maximum amount of memory that the virtual machine will attempt to use, measured in bytes  Results:\n Total Memory: 33554432 bytes = 32 MB üëà total allocated space¬†reserved for¬†the JVM Max Memory: 524288000 bytes = 500 MB üëà the maximum amount of memory that the JVM can use Available CPUs: 8  Let‚Äôs see my Docker Engine configuration on my laptop:\nDocker Engine configuration\n You can see that there are the 8 CPUs listed by the JShell, but the Memory allocated for the Docker Engine is 2GB and not 500MB ü§î Why it‚Äôs only 25% of the available memory? üò§\nLet‚Äôs do the same, with a Docker container with Memory limit of 800M and a CPU limit of 2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ docker container run -it --memory 800M --cpus 2 openjdk:10-jdk Dec 01, 2019 10:10:29 PM java.util.prefs.FileSystemPreferences$1 run INFO: Created user preferences directory. | Welcome to JShell -- Version 10.0.2 | For an introduction type: /help intro jshell Runtime.getRuntime().totalMemory() $1 == 14221312 jshell Runtime.getRuntime().maxMemory() $2 == 202768384 jshell Runtime.getRuntime().availableProcessors() $3 == 2   Results:\n Total Memory: 13.5625 MB Max Memory: 193.375 MB Available CPUs: 2  The Max Memory is approximately¬†25% of the 800MB memory that we allocated to our container ü§î\nWe can run an other command to check the maximum memory allocated for the JVM:\n1 2 3 4 5 6  $ docker container run -it --memory 800M --cpus 2 --entrypoint bash openjdk:10 root@ae152619006a:/# java -XX:+PrintFlagsFinal -version | grep MaxHeapSize size_t MaxHeapSize = 209715200 {product} {ergonomic} openjdk version \"10.0.2\" 2018-07-17 OpenJDK Runtime Environment (build 10.0.2+13-Debian-2) OpenJDK 64-Bit Server VM (build 10.0.2+13-Debian-2, mixed mode)   You can see here, that the MaxHeapSize is equal to 209715200 Bytes = 200 MB üòÅ more precisions ü•≥ But again, why it‚Äôs only 25% of the available memory? üò§\nThis is a default Java 10+ behavior, the JVM Heap will get 25% of the container‚Äôs memory. This is why we got only 25% of the allocated memory. üò≠\nDon‚Äôt worry ! There is a way to override the default 25% üßê we can pass a -XX:MaxRAMPercentage parameter with the desired value. Let‚Äôs test it:\n1 2 3 4 5 6 7  $ docker container run -it --memory 800M --cpus 2 --entrypoint bash openjdk:10 root@6327c67b8d35:/# java -XX:MaxRAMPercentage=50 \\  -XX:+PrintFlagsFinal -version | grep MaxHeapSize size_t MaxHeapSize = 419430400 {product} {ergonomic} openjdk version \"10.0.2\" 2018-07-17 OpenJDK Runtime Environment (build 10.0.2+13-Debian-2) OpenJDK 64-Bit Server VM (build 10.0.2+13-Debian-2, mixed mode)   When we defined the MaxRAMPercentage to 50%, we got 419430400 Bytes = 400MB, which is 50% of the 800M limit memory defined for the container.\n1 2 3 4 5 6 7  $ docker container run -it --memory 800M --cpus 2 --entrypoint bash openjdk:10 root@6327c67b8d35:/# java -XX:MaxRAMPercentage=100 \\  -XX:+PrintFlagsFinal -version | grep MaxHeapSize size_t MaxHeapSize = 838860800 {product} {ergonomic} openjdk version \"10.0.2\" 2018-07-17 OpenJDK Runtime Environment (build 10.0.2+13-Debian-2) OpenJDK 64-Bit Server VM (build 10.0.2+13-Debian-2, mixed mode)   Cool ! ü•≥ The -XX:MaxRAMPercentage parameter is also available on Java 8 starting from the update 191. But, it accepts only decimal value:\n1 2 3 4 5 6 7  $ docker container run -it --memory 800M --cpus 2 --entrypoint bash openjdk:8 root@5c441e3f56f3:/# java -XX:MaxRAMPercentage=50.0 \\  -XX:+PrintFlagsFinal -version | grep MaxHeapSize uintx MaxHeapSize := 419430400 {product} openjdk version \"1.8.0_232\" OpenJDK Runtime Environment (build 1.8.0_232-b09) OpenJDK 64-Bit Server VM (build 25.232-b09, mixed mode)   ü•≥ In this Java 8 based-container, we got the same MaxHeapSize value as the Java 10 container üòÅ\n‚ö†Ô∏è Important Note: it‚Äôs true that we can define the -XX:MaxRAMPercentage parameter to 100% but it‚Äôs not recommended and it‚Äôs even dangerous üò± but guess why ?\nImagine a situation: we want to deploy on our Kubernetes cluster a Java 10 based Docker image containing a Java application with a memory limit defined to 1GB. When the Pod will be created, it will have 1GB memory allocated to it. If we will have the -XX:MaxRAMPercentage parameter defined to 100%, the Java application running in the container can be consuming the total amount of the memory, which is the 2GB. In this case, the Pod will not have enough resources to have any Shell session, or even to be able to communicate with the kube api-server, etc.. So, the Kube Master will consider that this Pod is dead or unhealthy when it became unreachable.. so the Master will create a new Pod, and will kill the old one.. and when we will get the memory saturation.. a new Pod will be created and it will discard a the older one.. infinite loop ü•µ\nüí°A golden tip for defining the -XX:MaxRAMPercentage parameter to 75% only.. to let some space for the Pod internal processes üòé\nThere are other two JVM options have been added to allow Docker container users to gain more fine grained control over the amount of system memory that will be used for the Java Heap:\n -XX:InitialRAMPercentage: Set initial JVM Heap size as a percentage of the total memory -XX:MinRAMPercentage: Set the minimal JVM Heap size as a percentage of the total memory  Another recommended JVM option to use is the HeapDumpOnOutOfMemoryError which is used to tell the Java HotSpot VM to generate a heap dump when an allocation from the Java heap or the permanent generation cannot be satisfied. There is no overhead in running with this option, so it can be useful for production systems where the OutOfMemoryError exception takes a long time to surface. When the java.lang.OutOfMemoryError exception is thrown, a heap dump file is created. By default the heap dump is created in a file called java_pidpid.hprof in the working directory of the VM. We can specify an alternative file name or directory with the -XX:HeapDumpPath= option.\nFor example -XX:HeapDumpPath=/disk2/dumps will cause the heap dump to be generated in the /disk2/dumps directory.\nBefore the end The JVM options that we already saw can be integrated to the Dockerfile in the ENTRYPOINT Java command. But, this will require building an other image each time we want to change the values of the JVM options.\nA great solution is to integrate this JVM options in the JAVA_OPTS environment variable in the Kubernetes Deployment , which looks like:\n1 2 3 4 5 6 7 8 9 10 11  ...env:- name:JAVA_OPTSvalue:\"-XX:MinRAMPercentage=20.0 -XX:MaxRAMPercentage=75.0 -XX:+HeapDumpOnOutOfMemoryError\"...resources:limits:memory:512Mirequests:memory:256Mi...  That‚Äôs all tale ! üòÅ\nJava support for Docker Containers is a great new feature that comes with Java 10 (even ported to Java8 u191). It‚Äôs a very useful option in the most of the Java application deployed to Kubernetes ü•≥\n","wordCount":"1517","inLanguage":"en","image":"https://blog.nebrass.fr/images/playing-jvm-inside-containers.webp","datePublished":"2019-12-03T00:00:00Z","dateModified":"2019-12-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nebrass.fr/playing-with-the-jvm-inside-docker-containers/"},"publisher":{"@type":"Organization","name":"Nebrass Homepage","logo":{"@type":"ImageObject","url":"https://blog.nebrass.fr/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nebrass.fr accesskey=h title="Nebrass Homepage (Alt + H)">Nebrass Homepage</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://blog.nebrass.fr/ title=Posts><span>Posts</span></a></li><li><a href=https://blog.nebrass.fr/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nebrass.fr/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Playing with the JVM inside Docker Containers</h1><div class=post-meta><span title="2019-12-03 00:00:00 +0000 UTC">December 3, 2019</span>&nbsp;¬∑&nbsp;8 min</div></header><figure class=entry-cover><img loading=lazy src=https://blog.nebrass.fr/images/playing-jvm-inside-containers.webp alt></figure><div class=post-content><p>Nowadays, the most of the <strong>Java microservices</strong> and even many <strong>Java application</strong> are <strong>packaged and deployed as Docker containers</strong>. Everyone is enjoying (I hope üòÜ) the <strong>Docker</strong> experience, compared to the traditional <strong>VMs</strong>.¬†But, the <strong>Docker</strong> containerization will not come alone.. nothing is autonomous üòÅ So, there are many concerns to take into consideration while containerizing <strong>Java applications</strong>, like <strong>playing with the JVM</strong>.</p><p>The <strong>Docker</strong> racing was accelerated by the presence of <strong>Kubernetes</strong> in the market, which is coming with an amazing set of great features.</p><p>One of the great features available for <strong>handling the containers</strong> is having the option to control the resources allocated for a <strong>Pod üòÜ</strong> for example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>frontend</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>db</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MYSQL_ROOT_PASSWORD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;password&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;64Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;250m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;128Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>wp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>wordpress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;64Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;250m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;128Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This <code>yaml</code> resource descriptor will define <strong>CPU and Memory limits</strong> for the two containers running in this <code>frontend</code> <strong>Pod</strong>. These limits was not recognized by the <strong>JVM</strong> under <strong>Java</strong> versions until <strong>9 üò≠üò≠</strong>With the appearance of the <strong>Java 10</strong>, the <strong>JVM can now be aware of these limits</strong>. ü•≥</p><p>This great <a href=https://www.oracle.com/technetwork/java/javase/8u191-relnotes-5032181.html>support was even ported to the JDK 8 update 191</a>.</p><h2 id=what-are-these-great-improvements-for-docker-containers->what are these great Improvements for Docker Containers ?<a hidden class=anchor aria-hidden=true href=#what-are-these-great-improvements-for-docker-containers->#</a></h2><p>We can quickly start testing the awareness of the <strong>JVM</strong> under <strong>Java 10</strong> of the <strong>Container</strong> limits that we can put:</p><p>Let&rsquo;s create a <strong>Docker container</strong> without any limits. In the created container, we will be running the <strong>JShell</strong> to test <strong>what information do we have in the Runtime?</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -it openjdk:10-jdk 
</span></span><span class=line><span class=cl>Dec 02, <span class=m>2019</span> 8:14:54 AM java.util.prefs.FileSystemPreferences<span class=nv>$1</span> run
</span></span><span class=line><span class=cl>INFO: Created user preferences directory.
</span></span><span class=line><span class=cl><span class=p>|</span>  Welcome to JShell -- Version 10.0.2
</span></span><span class=line><span class=cl><span class=p>|</span>  For an introduction type: /help intro
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>jshell&gt; Runtime.getRuntime<span class=o>()</span>.totalMemory<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span> <span class=o>==</span>&gt; <span class=m>33554432</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>jshell&gt; Runtime.getRuntime<span class=o>()</span>.maxMemory<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span> <span class=o>==</span>&gt; <span class=m>524288000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>jshell&gt; Runtime.getRuntime<span class=o>()</span>.availableProcessors<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span> <span class=o>==</span>&gt; <span class=m>8</span>
</span></span></code></pre></td></tr></table></div></div><p>Before digging into the returned values, what are these methods ?</p><p>Based on the <code>Javadoc</code> of the <strong>Runtime</strong> class:</p><ul><li><strong>totalMemory()</strong> Gives the total amount of memory in the Java virtual machine. The value returned by this method may vary over time, depending on the host environment. Note that the amount of memory required to hold an object of any given type may be implementation-dependent. <strong>Returns:</strong> the total amount of memory currently available for current and future objects, measured in bytes.</li><li><strong>maxMemory()</strong> Gives the maximum amount of memory that the Java virtual machine will attempt to use. If there is no inherent limit then the value Long.MAX_VALUE will be returned. <strong>Returns:</strong> the maximum amount of memory that the virtual machine will attempt to use, measured in bytes</li></ul><p>Results:</p><ul><li>Total Memory: 33554432 bytes = <strong>32 MB</strong> üëà ¬†total allocated space¬†<strong>reserved</strong> for¬†the <strong>JVM</strong></li><li>Max Memory: 524288000 bytes = <strong>500 MB</strong> üëà the maximum amount of memory that the <strong>JVM</strong> can use</li><li>Available CPUs: <strong>8</strong></li></ul><p>Let&rsquo;s see my <strong>Docker Engine configuration</strong> on my laptop:</p><div align=center><p><img loading=lazy src=../images/jvm-container-docker-configuration.webp alt="Docker Engine configuration" title="Docker Engine configuration">
Docker Engine configuration</p></div><p>You can see that there are the <strong>8 CPUs</strong> listed by the <strong>JShell</strong>, but the <strong>Memory</strong> allocated for the <strong>Docker Engine is 2GB and not 500MB</strong> ü§î Why it&rsquo;s only 25% of the available memory? üò§</p><p>Let&rsquo;s do the same, with a <strong>Docker container</strong> with <strong>Memory limit of 800M</strong> and a <strong>CPU limit of 2</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -it --memory 800M --cpus <span class=m>2</span> openjdk:10-jdk
</span></span><span class=line><span class=cl>Dec 01, <span class=m>2019</span> 10:10:29 PM java.util.prefs.FileSystemPreferences<span class=nv>$1</span> run
</span></span><span class=line><span class=cl>INFO: Created user preferences directory.
</span></span><span class=line><span class=cl><span class=p>|</span>  Welcome to JShell -- Version 10.0.2
</span></span><span class=line><span class=cl><span class=p>|</span>  For an introduction type: /help intro
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>jshell&gt; Runtime.getRuntime<span class=o>()</span>.totalMemory<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span> <span class=o>==</span>&gt; <span class=m>14221312</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>jshell&gt; Runtime.getRuntime<span class=o>()</span>.maxMemory<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span> <span class=o>==</span>&gt; <span class=m>202768384</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>jshell&gt; Runtime.getRuntime<span class=o>()</span>.availableProcessors<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span> <span class=o>==</span>&gt; <span class=m>2</span>
</span></span></code></pre></td></tr></table></div></div><p>Results:</p><ul><li>Total Memory: <strong>13.5625 MB</strong></li><li>Max Memory: <strong>193.375 MB</strong></li><li>Available CPUs: <strong>2</strong></li></ul><p>The <strong>Max Memory</strong> is <strong>approximately¬†25%</strong> of the <strong>800MB</strong> memory that we allocated to our container ü§î</p><p>We can run an other command to check the maximum memory allocated for the JVM:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -it --memory 800M --cpus <span class=m>2</span> --entrypoint bash openjdk:10    
</span></span><span class=line><span class=cl>root@ae152619006a:/# java -XX:+PrintFlagsFinal -version <span class=p>|</span> grep MaxHeapSize
</span></span><span class=line><span class=cl>   size_t <span class=nv>MaxHeapSize</span>         <span class=o>=</span>   <span class=m>209715200</span>         <span class=o>{</span>product<span class=o>}</span> <span class=o>{</span>ergonomic<span class=o>}</span>
</span></span><span class=line><span class=cl>openjdk version <span class=s2>&#34;10.0.2&#34;</span> 2018-07-17
</span></span><span class=line><span class=cl>OpenJDK Runtime Environment <span class=o>(</span>build 10.0.2+13-Debian-2<span class=o>)</span>
</span></span><span class=line><span class=cl>OpenJDK 64-Bit Server VM <span class=o>(</span>build 10.0.2+13-Debian-2, mixed mode<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>You can see here, that the <code>MaxHeapSize</code> is equal to <strong>209715200 Bytes</strong> = <strong>200 MB üòÅ</strong> more precisions <strong>ü•≥</strong> But again, why it&rsquo;s <strong>only 25% of the available memory</strong>? üò§</p><p>This is a default <strong>Java 10+ behavior</strong>, the <strong>JVM Heap will get 25%</strong> of <strong>the container‚Äôs memory</strong>. This is why <strong>we got only 25% of the allocated memory</strong>. üò≠</p><p>Don&rsquo;t worry ! There is a way to override the default 25% üßê we can pass a <code>-XX:MaxRAMPercentage</code> parameter with the desired value. Let&rsquo;s test it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -it --memory 800M --cpus <span class=m>2</span> --entrypoint bash openjdk:10
</span></span><span class=line><span class=cl>root@6327c67b8d35:/# java -XX:MaxRAMPercentage<span class=o>=</span><span class=m>50</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            -XX:+PrintFlagsFinal -version <span class=p>|</span> grep MaxHeapSize
</span></span><span class=line><span class=cl>   size_t <span class=nv>MaxHeapSize</span>       <span class=o>=</span>       <span class=m>419430400</span>       <span class=o>{</span>product<span class=o>}</span> <span class=o>{</span>ergonomic<span class=o>}</span>
</span></span><span class=line><span class=cl>openjdk version <span class=s2>&#34;10.0.2&#34;</span> 2018-07-17
</span></span><span class=line><span class=cl>OpenJDK Runtime Environment <span class=o>(</span>build 10.0.2+13-Debian-2<span class=o>)</span>
</span></span><span class=line><span class=cl>OpenJDK 64-Bit Server VM <span class=o>(</span>build 10.0.2+13-Debian-2, mixed mode<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>When we defined the <code>MaxRAMPercentage</code> to <strong>50%</strong>, we got 419430400 Bytes = <strong>400MB</strong>, which is <strong>50%</strong> of the <strong>800M limit</strong> memory defined for the container.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -it --memory 800M --cpus <span class=m>2</span> --entrypoint bash openjdk:10
</span></span><span class=line><span class=cl>root@6327c67b8d35:/# java -XX:MaxRAMPercentage<span class=o>=</span><span class=m>100</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            -XX:+PrintFlagsFinal -version <span class=p>|</span> grep MaxHeapSize
</span></span><span class=line><span class=cl>   size_t <span class=nv>MaxHeapSize</span>       <span class=o>=</span>       <span class=m>838860800</span>       <span class=o>{</span>product<span class=o>}</span> <span class=o>{</span>ergonomic<span class=o>}</span>
</span></span><span class=line><span class=cl>openjdk version <span class=s2>&#34;10.0.2&#34;</span> 2018-07-17
</span></span><span class=line><span class=cl>OpenJDK Runtime Environment <span class=o>(</span>build 10.0.2+13-Debian-2<span class=o>)</span>
</span></span><span class=line><span class=cl>OpenJDK 64-Bit Server VM <span class=o>(</span>build 10.0.2+13-Debian-2, mixed mode<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Cool ! ü•≥ The <code>-XX:MaxRAMPercentage</code> parameter is also available on <strong>Java 8 starting from the update 191</strong>. But, it accepts only decimal value:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -it --memory 800M --cpus <span class=m>2</span> --entrypoint bash openjdk:8 
</span></span><span class=line><span class=cl>root@5c441e3f56f3:/# java -XX:MaxRAMPercentage<span class=o>=</span>50.0 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>                            -XX:+PrintFlagsFinal -version <span class=p>|</span> grep MaxHeapSize
</span></span><span class=line><span class=cl>    uintx MaxHeapSize       :<span class=o>=</span>      <span class=m>419430400</span>       <span class=o>{</span>product<span class=o>}</span>
</span></span><span class=line><span class=cl>openjdk version <span class=s2>&#34;1.8.0_232&#34;</span>
</span></span><span class=line><span class=cl>OpenJDK Runtime Environment <span class=o>(</span>build 1.8.0_232-b09<span class=o>)</span>
</span></span><span class=line><span class=cl>OpenJDK 64-Bit Server VM <span class=o>(</span>build 25.232-b09, mixed mode<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>ü•≥ In this <strong>Java 8</strong> based-container, we got the same <code>MaxHeapSize</code> value as the <strong>Java 10</strong> container üòÅ</p><p>‚ö†Ô∏è <strong>Important Note:</strong> it&rsquo;s true that we can define the <code>-XX:MaxRAMPercentage</code> parameter to 100% but it&rsquo;s not recommended and it&rsquo;s even dangerous üò± but guess why ?</p><p>Imagine a situation: we want to deploy on our <strong>Kubernetes</strong> cluster a <strong>Java 10</strong> based <strong>Docker image</strong> containing a <strong>Java</strong> application with a memory limit defined to <strong>1GB</strong>. When the <strong>Pod</strong> will be created, it will have <strong>1GB</strong> memory allocated to it. If we will have the <code>-XX:MaxRAMPercentage</code> parameter defined to 100%, the <strong>Java</strong> application running in the container can be consuming the total amount of the memory, which is the <strong>2GB</strong>. In this case, the <strong>Pod</strong> will not have enough resources to have <strong>any Shell session,</strong> or even to be able to communicate with the <code>kube api-server</code>, etc.. So, the <strong>Kube Master</strong> will consider that this Pod is dead or unhealthy when it became unreachable.. so the <strong>Master</strong> will create a new Pod, and will kill the old one.. and when we will get the memory saturation.. a new <strong>Pod</strong> will be created and it will discard a the older one.. infinite loop ü•µ</p><p>üí°A golden tip for defining the <code>-XX:MaxRAMPercentage</code> parameter to 75% only.. to let some space for the <strong>Pod</strong> internal processes üòé</p><p>There are other two <strong>JVM options</strong> have been added to allow <strong>Docker container</strong> users to gain more fine grained control over the amount of system memory that will be used for the <strong>Java Heap</strong>:</p><ul><li><code>-XX:InitialRAMPercentage</code>: Set initial <strong>JVM Heap size</strong> as a percentage of the total memory</li><li><code>-XX:MinRAMPercentage</code>: Set the minimal <strong>JVM Heap size</strong> as a percentage of the total memory</li></ul><p>Another recommended <strong>JVM option</strong> to use is the <code>HeapDumpOnOutOfMemoryError</code> which is used to tell the <strong>Java HotSpot VM</strong> to generate a <strong>heap dump</strong> when an allocation from the <strong>Java heap</strong> or the <strong>permanent generation</strong> cannot be satisfied. There is no overhead in running with this option, so it can be useful for production systems where the <code>OutOfMemoryError</code> exception takes a long time to surface. When the <code>java.lang.OutOfMemoryError</code> exception is thrown, a <strong>heap dump</strong> file is created. By default the <strong>heap dump</strong> is created in a file called <code>java_pidpid.hprof</code> in the working directory of the <strong>VM</strong>. We can specify an alternative file name or directory with the <code>-XX:HeapDumpPath=</code> option.</p><p>For example <code>-XX:HeapDumpPath=/disk2/dumps</code> will cause the heap dump to be generated in the <code>/disk2/dumps</code> directory.</p><h2 id=before-the-end>Before the end<a hidden class=anchor aria-hidden=true href=#before-the-end>#</a></h2><p>The <strong>JVM options</strong> that we already saw can be integrated to the <code>Dockerfile</code> in the <code>ENTRYPOINT</code> <strong>Java</strong> command. But, this will require building an other image each time we want to change the values of the <strong>JVM options</strong>.</p><p>A great solution is to integrate this JVM options in the <code>JAVA_OPTS</code> environment variable in the <strong>Kubernetes Deployment</strong> , which looks like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>JAVA_OPTS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;-XX:MinRAMPercentage=20.0 -XX:MaxRAMPercentage=75.0 -XX:+HeapDumpOnOutOfMemoryError&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>resources</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>512Mi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>256Mi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>That&rsquo;s all tale ! üòÅ</p><p><strong>Java support</strong> for <strong>Docker Containers</strong> is a great new feature that comes with <strong>Java 10</strong> (even ported to <strong>Java8 u191</strong>). It&rsquo;s a very useful option in the most of the <strong>Java application</strong> deployed to <strong>Kubernetes</strong> ü•≥</p></div><footer class=post-footer><ul class=post-tags></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Playing with the JVM inside Docker Containers on twitter" href="https://twitter.com/intent/tweet/?text=Playing%20with%20the%20JVM%20inside%20Docker%20Containers&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with the JVM inside Docker Containers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f&title=Playing%20with%20the%20JVM%20inside%20Docker%20Containers&summary=Playing%20with%20the%20JVM%20inside%20Docker%20Containers&source=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with the JVM inside Docker Containers on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f&title=Playing%20with%20the%20JVM%20inside%20Docker%20Containers"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with the JVM inside Docker Containers on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with the JVM inside Docker Containers on whatsapp" href="https://api.whatsapp.com/send?text=Playing%20with%20the%20JVM%20inside%20Docker%20Containers%20-%20https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with the JVM inside Docker Containers on telegram" href="https://telegram.me/share/url?text=Playing%20with%20the%20JVM%20inside%20Docker%20Containers&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-the-jvm-inside-docker-containers%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.nebrass.fr>Nebrass Homepage</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>