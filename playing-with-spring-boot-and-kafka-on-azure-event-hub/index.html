<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Playing with Spring Boot and Kafka on Azure Event Hub | Nebrass Homepage</title><meta name=keywords content><meta name=description content="In an enterprise level, it&rsquo;s obvious for applications to be based on messaging for communication. This is done using a middleware between these applications as a Message Bus that enables them to work together.
One of the most used Messaging solutions is Apache Kafka: Kafka is an open-source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation, written in Scala and Java. The project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds."><meta name=author content><link rel=canonical href=https://blog.nebrass.fr/playing-with-spring-boot-and-kafka-on-azure-event-hub/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9aeab43847eb11aca320bfadedfe191ed6516dd768bf1314b534c4992aac901a.css integrity="sha256-muq0OEfrEayjIL+t7f4ZHtZRbddovxMUtTTEmSqskBo=" rel="preload stylesheet" as=style><script src=/js/prism.min.js></script>
<link rel=stylesheet href=/css/prism.min.css><link rel=icon href=https://blog.nebrass.fr/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.nebrass.fr/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.nebrass.fr/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.nebrass.fr/apple-touch-icon.png><link rel=mask-icon href=https://blog.nebrass.fr/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style amp-custom>.main,.footer,.nav{max-width:calc(var(--main-width) + var(--gap) * 15)}</style><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-111781986-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Playing with Spring Boot and Kafka on Azure Event Hub"><meta property="og:description" content="In an enterprise level, it&rsquo;s obvious for applications to be based on messaging for communication. This is done using a middleware between these applications as a Message Bus that enables them to work together.
One of the most used Messaging solutions is Apache Kafka: Kafka is an open-source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation, written in Scala and Java. The project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.nebrass.fr/playing-with-spring-boot-and-kafka-on-azure-event-hub/"><meta property="og:image" content="https://blog.nebrass.fr/images/playing-springboot-kafka-eventhub.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nebrass.fr/images/playing-springboot-kafka-eventhub.webp"><meta name=twitter:title content="Playing with Spring Boot and Kafka on Azure Event Hub"><meta name=twitter:description content="In an enterprise level, it&rsquo;s obvious for applications to be based on messaging for communication. This is done using a middleware between these applications as a Message Bus that enables them to work together.
One of the most used Messaging solutions is Apache Kafka: Kafka is an open-source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation, written in Scala and Java. The project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.nebrass.fr/posts/"},{"@type":"ListItem","position":3,"name":"Playing with Spring Boot and Kafka on Azure Event Hub","item":"https://blog.nebrass.fr/playing-with-spring-boot-and-kafka-on-azure-event-hub/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Playing with Spring Boot and Kafka on Azure Event Hub","name":"Playing with Spring Boot and Kafka on Azure Event Hub","description":"In an enterprise level, it\u0026rsquo;s obvious for applications to be based on messaging for communication. This is done using a middleware between these applications as a Message Bus that enables them to work together.\nOne of the most used Messaging solutions is Apache Kafka: Kafka is an open-source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation, written in Scala and Java. The project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds.","keywords":[],"articleBody":"In an enterprise level, it‚Äôs obvious for applications to be based on messaging for communication. This is done using a middleware between these applications as a Message Bus that enables them to work together.\nOne of the most used Messaging solutions is Apache Kafka: Kafka is an open-source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation, written in Scala and Java. The project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds. It is horizontally scalable, fault-tolerant, wicked fast, and runs in production in thousands of companies. Kafka Clusters can be deployed in bare metal or in the Cloud.\nMicrosoft provides a great Azure Service for Kafka customers: Azure Event Hubs ü§©\nAzure Event Hubs is a fully managed, real-time data ingestion service that‚Äôs simple, trusted, and scalable. It provides streaming millions of events per second from any source to build dynamic data pipelines and immediately respond to business challenges. Azure Event Hubs keeps processing data during emergencies using the geo-disaster recovery and geo-replication features.\nAzure Event Hubs allows existing Apache Kafka clients and applications to talk to Event Hubs without any code changes‚Äîyou get a managed Kafka experience without having to manage your own clusters.\nIn this tutorial, I will try to make two small Spring Boot applications that will communicate thru the Azure Event Hubs.\nThe source code of the sample application that we will be developing in this post is available on Github.\nCreating an azure event hubs namespace First of all, we need to start by creating the Event Hubs Namespace:\n Name will be used for creating the Event Hubs Namespace URL Pricing Tier: Standard - The Kafka support is enabled for the Standard and Dedicated pricing tiers only.  Authorizing the access to the azure event hubs namespace Each Event Hubs namespace and each Event Hubs entity (an event hub instance or a Kafka topic) has a shared access authorization policy made up of rules. The policy at the namespace level applies to all entities inside the namespace, irrespective of their individual policy configuration. For each authorization policy rule, you decide on three pieces of information: name, scope, and rights. The name is a unique name in that scope. The scope is the URI of the resource in question. For an Event Hubs namespace, the scope is the fully qualified domain name (FQDN), such as¬†https://.servicebus.windows.net/.\nThe rights provided by the policy rule can be a combination of:\n Send¬†‚Äì Gives the right to send messages to the entity Listen¬†‚Äì Gives the right to listen or receive to the entity Manage¬†‚Äì Gives the right to manage the topology of the namespace, including creation and deletion of entities  In our case we need to create a Shared Access Authorization Policy that can be Sending and Listening to our Event Hubs namespace:\nCreating an azure event hub Next, in my nebrass namespace, I will create a new Event Hub called topic-exchange¬†ü•≥\ngenerating our sample application project As usual, we will generate our project using the Spring Initializr. Our application will have 3 dependencies:\n Web Kafka Lombok  As you see here, there is no specific Azure dependency or specific library.\n In our example, we will have an application that is producing/consuming Kafka messages. Generally, in many tutorials you will find separated producer and consumer applications. But in our application, I wanted to have to have both features in the same application, which is a real world use case. ‚ö†Ô∏è It‚Äôs not mandatory that the producer application is not listening to the same source üòÖ\n Now we will be creating our Kafka application üòÅ\nLet‚Äôs start by renaming the application.properties to application.yaml - I like to use YAML üòÅ and we will insert the first value inside, which is the name of the Topic we want to write to:\n1 2  topic:name:exchange-topic  This topic name can be injected into the code using :\n1 2  @Value(\"${topic.name}\") private String topicName;   Now, let‚Äôs move to defining the structure of our Kafka message, that we will be producing and consuming - our Message will be a small POJO with only one String body attribute :\n1 2 3 4 5 6  @Getter @NoArgsConstructor @AllArgsConstructor public class SimpleMessage { private String body; }   With the message, we need to add a JSON Serializer, which obviously ü§£ will be used to Serialize our message to JSON ü•∂\n1 2  public class ProducerMessageSerializer extends JsonSerializerSimpleMessage { }   Next, we can now create our Kafka producer, which will be a Spring Service:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  @Slf4j @Service @RequiredArgsConstructor public class KafkaProducer { private final KafkaTemplateString, SimpleMessage kafkaTemplate; @Value(\"${topic.name}\") private String topicName; public void send(SimpleMessage message) { this.kafkaTemplate.send(topicName, message); log.info(\"Published the message [{}] to the kafka queue: [{}]\", message.getBody(), topicName ); } }   But where the data will be sent ? üò± We need to go back to the application.yaml file to add some (many) configuration details: ü§ì\n1 2 3 4 5 6 7 8 9 10 11 12  spring:kafka:bootstrap-servers:nebrass.servicebus.windows.net:9093client-id:first-serviceproperties:sasl.jaas.config:org.apache.kafka.common.security.plain.PlainLoginModule required username=\"$ConnectionString\" password=\"Endpoint=sb://nebrass.servicebus.windows.net/;SharedAccessKeyName=SendReceiveOnly;SharedAccessKey=XXXX\";sasl.mechanism:PLAINsecurity.protocol:SASL_SSLproducer:value-serializer:com.targa.labs.dev.kafkaonazure.ProducerMessageSerializertopic:name:exchange-topic  Wow üò± There are many items added to the list. Keep calm, it‚Äôs very simple configuration:\n spring.kafka.bootstrap-servers: Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster üëâ This value is extracted by the Event Hubs name, in my case it‚Äôs: nebrass.servicebus.windows.net:9093 spring.kafka.client-id: ID to pass to the server when making requests. Used for server-side logging üëâ first-service spring.kafka.properties.sasl.mechanism: PLAIN üëâ PLAIN (also known as SASL/PLAIN) is a simple username/password authentication mechanism that is typically used with TLS for encryption to implement secure authentication. spring.kafka.properties.security.protocol: SASL_SSL üëâ this property ensures that all broker/client communication is encrypted and authenticated using SASL/PLAIN spring.kafka.properties.sasl.jaas.config: Configure the JAAS configuration property to describe how the clients like producer and consumer can connect to the Kafka Brokers. The properties username and password are used by clients to configure the user for client connections. In our example, clients connect to the broker as the username is ‚Äú$ConnectionString‚Äù and the password will be our Azure EventHubs ConnectionString which is in our case the connection string of our Shared Access Authorization Policy. We will be using org.apache.kafka.common.security.plain.PlainLoginModule as the login module implementation which should provide username as the public credential and password as the private credential üëâ so our property value will be: org.apache.kafka.common.security.plain.PlainLoginModule required username=\"$ConnectionString\" password=‚ÄúEndpoint=sb://nebrass.servicebus.windows.net/;SharedAccessKeyName=SendReceiveOnly;SharedAccessKey=XXXX‚Äù; spring.kafka.producer.value-serializer: Serializer class for values üëâ com.targa.labs.dev.kafkaonazure.ProducerMessageSerializer  Expose the kafka producer We will be inserting Kafka messages with a content received from a REST API. So for this, we will create a new RestController:\n1 2 3 4 5 6 7 8 9 10 11 12  @RestController @RequestMapping(\"/api\") @RequiredArgsConstructor public class KafkaSender { private final KafkaProducer kafkaProducer; @PostMapping(\"send\") public void sendData(@RequestBody SimpleMessage message) { this.kafkaProducer.send(message); } }   We can send some messages using Postman/Insomnia or even via command line, for example, using cURL:\n1  curl -d '{\"body\": \"Hello there !\"}' -H \"Content-Type: application/json\" -X POST http://localhost:8080/api/send   Creating the Kafka consumer The same way we did the Kafka Producer, our Kafka Consumer will be a classic Spring Service with a method annotated with @KafkaListener on our Event Hub:\n1 2 3 4 5 6 7 8 9  @Service @Slf4j public class KafkaConsumer { @KafkaListener(topics = \"${topic.name}\") public void receive(SimpleMessage consumerMessage) { log.info(\"Received message from kafka queue: {}\", consumerMessage.getBody()); } }   So simple ! üòÅ but this will not be working, unless we add the Spring Kafka Consumer configuration in our application.yaml file:\n1 2 3 4 5 6 7 8 9  spring:kafka:...consumer:group-id:$Defaultproperties:spring.json:use.type.headers:falsevalue.default.type:com.targa.labs.dev.kafkaonazure.SimpleMessage  The listed configuration is:\n spring.kafka.consumer.group-id: required and unique string that identifies the consumer group this consumer belongs to. üëâ in our case it will be $Default to use the basic consumer group that was created when we created our Azure Event Hub. spring.kafka.consumer.properties.spring.json.use.type.headers: to prevent the Consumer even looking for headers üëâ in our case it will be false spring.kafka.consumer.properties.spring.json.value.default.type: the message to be consumed üëâ com.microsoft.cse.labs.kafkaeventhub.SimpleMessage  Cool ! Now our application will be producing a message to the Azure Event Hub, and it will be receiving it as soon as it is available üòÅ the final diagram of our ecosystem is:\nFinal words As you can see in our application, we don‚Äôt have any specific library or connector of Azure. We are developing a plain Spring Kafka application and we are just plugging it to Azure Event Hubs instead of a classic Kafka broker. The facility of developing without any constraints of the target broker is a huge add-on for the customers willing to move their applications to Azure Event Hubs. This abstraction and portability is one of the most wanted facility of the Java EE specifications, such as the abstraction for the JPA specification and the ability to be plugged to any Relational DBMS.\n","wordCount":"1464","inLanguage":"en","image":"https://blog.nebrass.fr/images/playing-springboot-kafka-eventhub.webp","datePublished":"2020-03-01T00:00:00Z","dateModified":"2020-03-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nebrass.fr/playing-with-spring-boot-and-kafka-on-azure-event-hub/"},"publisher":{"@type":"Organization","name":"Nebrass Homepage","logo":{"@type":"ImageObject","url":"https://blog.nebrass.fr/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nebrass.fr accesskey=h title="Nebrass Homepage (Alt + H)">Nebrass Homepage</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://blog.nebrass.fr/ title=Posts><span>Posts</span></a></li><li><a href=https://blog.nebrass.fr/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nebrass.fr/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Playing with Spring Boot and Kafka on Azure Event Hub</h1><div class=post-meta><span title="2020-03-01 00:00:00 +0000 UTC">March 1, 2020</span>&nbsp;¬∑&nbsp;7 min</div></header><figure class=entry-cover><img loading=lazy src=https://blog.nebrass.fr/images/playing-springboot-kafka-eventhub.webp alt></figure><div class=post-content><p>In an enterprise level, it&rsquo;s obvious for applications to be based on messaging for communication. This is done using a middleware between these applications as a <strong><em>Message Bus</em></strong> that enables them to work together.</p><p><img loading=lazy src=../images/messaging-bus-architecture-1024x755.webp alt="Messaging Bus Architecture" title="Messaging Bus Architecture"></p><p>One of the most used Messaging solutions is <strong>Apache Kafka</strong>: <strong>Kafka</strong> is an open-source stream-processing software platform <strong>developed by LinkedIn</strong> and <strong>donated to the Apache Software Foundation</strong>, written in <strong>Scala</strong> and <strong>Java</strong>. The project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds. It is horizontally scalable, fault-tolerant, wicked fast, and runs in production in thousands of companies. <strong>Kafka Clusters</strong> can be deployed in bare metal or in the <strong>Cloud</strong>.</p><p><strong>Microsoft</strong> provides a great <strong>Azure Service</strong> for <strong>Kafka</strong> customers: <strong>Azure Event Hubs</strong> ü§©</p><p><strong>Azure Event Hubs</strong> is a fully managed, real-time data ingestion service that‚Äôs simple, trusted, and scalable. It provides streaming millions of events per second from any source to build dynamic data pipelines and immediately respond to business challenges. <strong>Azure Event Hubs</strong> keeps processing data during emergencies using the geo-disaster recovery and geo-replication features.</p><p><strong>Azure Event Hubs</strong> allows existing <strong>Apache Kafka</strong> clients and applications to talk to <strong>Event Hubs</strong> without any code changes‚Äîyou get <strong>a managed Kafka experience</strong> without having to manage your own clusters.</p><p>In this tutorial, I will try to make <strong>two small Spring Boot applications</strong> that will communicate thru the <strong>Azure Event Hubs</strong>.</p><p>The source code of the sample application that we will be developing in this post <a href=https://github.com/nebrass/playing-with-spring-boot-and-kafka-on-azure-event-hub>is available on Github</a>.</p><h2 id=creating-an-azure-event-hubs-namespace>Creating an azure event hubs namespace<a hidden class=anchor aria-hidden=true href=#creating-an-azure-event-hubs-namespace>#</a></h2><p>First of all, we need to start by creating the <strong>Event Hubs Namespace</strong>:</p><ul><li><strong>Name</strong> will be used for creating the <strong>Event Hubs Namespace URL</strong></li><li><strong>Pricing Tier</strong>: Standard - The <strong>Kafka support</strong> is enabled for the <strong>Standard and Dedicated pricing tiers only</strong>.</li></ul><p><img loading=lazy src=../images/creating-azure-eventhubs.webp alt="Creating the Azure Event Hubs" title="Creating the Azure Event Hubs"></p><h2 id=authorizing-the-access-to-the-azure-event-hubs-namespace>Authorizing the access to the azure event hubs namespace<a hidden class=anchor aria-hidden=true href=#authorizing-the-access-to-the-azure-event-hubs-namespace>#</a></h2><p>Each <strong>Event Hubs namespace</strong> and each Event Hubs entity (an event hub instance or a Kafka topic) has a shared access authorization policy made up of rules. The policy at the namespace level applies to all entities inside the namespace, irrespective of their individual policy configuration. For each authorization policy rule, you decide on three pieces of information: name, scope, and rights. The name is a unique name in that scope. The scope is the URI of the resource in question. For an <strong>Event Hubs namespace</strong>, the scope is the fully qualified domain name (FQDN), such as¬†<code>https://&lt;yournamespace>.servicebus.windows.net/</code>.</p><p>The rights provided by the policy rule can be a combination of:</p><ul><li><strong>Send</strong>¬†‚Äì Gives the right to send messages to the entity</li><li><strong>Listen</strong>¬†‚Äì Gives the right to listen or receive to the entity</li><li><strong>Manage</strong>¬†‚Äì Gives the right to manage the topology of the namespace, including creation and deletion of entities</li></ul><p>In our case we need to create a <strong>Shared Access Authorization Policy</strong> that can be <strong>Sending and Listening</strong> to our <strong>Event Hubs namespace</strong>:</p><p><img loading=lazy src=../images/azure-eventhubs-sas-policy.webp alt="Creating the Azure Event Hubs Shared Access Policy" title="Creating the Azure Event Hubs Shared Access Policy"></p><h2 id=creating-an-azure-event-hub>Creating an azure event hub<a hidden class=anchor aria-hidden=true href=#creating-an-azure-event-hub>#</a></h2><p>Next, in my <strong>nebrass</strong> <em>namespace</em>, I will create a new <strong>Event Hub</strong> called <strong>topic-exchange</strong>¬†ü•≥</p><p><img loading=lazy src=../images/azure-eventhubs-creating-event-hub.webp alt="Creating an Azure Event Hub" title="Creating an Azure Event Hub"></p><h2 id=generating-our-sample-application-project>generating our sample application project<a hidden class=anchor aria-hidden=true href=#generating-our-sample-application-project>#</a></h2><p>As usual, we will generate our project using the <em><strong>Spring Initializr</strong></em>. Our application will have 3 dependencies:</p><ul><li>Web</li><li>Kafka</li><li>Lombok</li></ul><p><img loading=lazy src=../images/azure-kafka-spring-initializr.webp alt="Generating the project skull on Spring Initializr" title="Generating the project skull on Spring Initializr"></p><p>As you see here, there is no specific Azure dependency or specific library.</p><blockquote><p>In our example, we will have an application that is producing/consuming Kafka messages. Generally, in many tutorials you will find separated producer and consumer applications. But in our application, I wanted to have to have both features in the same application, which is a real world use case. ‚ö†Ô∏è It&rsquo;s not mandatory that the producer application is not listening to the same source üòÖ</p></blockquote><p>Now we will be creating our Kafka application üòÅ</p><p>Let&rsquo;s start by renaming the application.properties to application.yaml - I like to use YAML üòÅ and we will insert the first value inside, which is the name of the Topic we want to write to:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>topic</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>exchange-topic</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This topic name can be injected into the code using :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Value</span><span class=o>(</span><span class=s>&#34;${topic.name}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>String</span> <span class=n>topicName</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>Now, let&rsquo;s move to defining the structure of our Kafka message, that we will be producing and consuming - our Message will be a small POJO with only one String body attribute :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Getter</span>
</span></span><span class=line><span class=cl><span class=nd>@NoArgsConstructor</span>
</span></span><span class=line><span class=cl><span class=nd>@AllArgsConstructor</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SimpleMessage</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>body</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>With the message, we need to add a JSON Serializer, which obviously ü§£ will be used to Serialize our message to JSON ü•∂</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ProducerMessageSerializer</span> <span class=kd>extends</span> <span class=n>JsonSerializer</span><span class=o>&lt;</span><span class=n>SimpleMessage</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Next, we can now create our Kafka producer, which will be a Spring Service:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=nd>@Service</span>
</span></span><span class=line><span class=cl><span class=nd>@RequiredArgsConstructor</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KafkaProducer</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>KafkaTemplate</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>SimpleMessage</span><span class=o>&gt;</span> <span class=n>kafkaTemplate</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Value</span><span class=o>(</span><span class=s>&#34;${topic.name}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>topicName</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>send</span><span class=o>(</span><span class=n>SimpleMessage</span> <span class=n>message</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>kafkaTemplate</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>topicName</span><span class=o>,</span> <span class=n>message</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;Published the message [{}] to the kafka queue: [{}]&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                <span class=n>message</span><span class=o>.</span><span class=na>getBody</span><span class=o>(),</span>
</span></span><span class=line><span class=cl>                <span class=n>topicName</span>
</span></span><span class=line><span class=cl>        <span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>But where the data will be sent ? üò± We need to go back to the <code>application.yaml</code> file to add some (many) configuration details: ü§ì</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spring</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>kafka</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>bootstrap-servers</span><span class=p>:</span><span class=w> </span><span class=l>nebrass.servicebus.windows.net:9093</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>client-id</span><span class=p>:</span><span class=w> </span><span class=l>first-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>sasl.jaas.config</span><span class=p>:</span><span class=w> </span><span class=l>org.apache.kafka.common.security.plain.PlainLoginModule required username=&#34;$ConnectionString&#34; password=&#34;Endpoint=sb://nebrass.servicebus.windows.net/;SharedAccessKeyName=SendReceiveOnly;SharedAccessKey=XXXX&#34;;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>sasl.mechanism</span><span class=p>:</span><span class=w> </span><span class=l>PLAIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>security.protocol</span><span class=p>:</span><span class=w> </span><span class=l>SASL_SSL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>producer</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>value-serializer</span><span class=p>:</span><span class=w> </span><span class=l>com.targa.labs.dev.kafkaonazure.ProducerMessageSerializer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>topic</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>exchange-topic</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Wow üò± There are many items added to the list. Keep calm, it&rsquo;s very simple configuration:</p><ul><li><strong>spring.kafka.bootstrap-servers</strong>: Comma-delimited list of <strong>host:port</strong> pairs to use for establishing the initial connections to the Kafka cluster üëâ This value is extracted by the Event Hubs name, in my case it&rsquo;s: <strong>nebrass.servicebus.windows.net:9093</strong></li><li><strong>spring.kafka.client-id</strong>: ID to pass to the server when making requests. Used for server-side logging üëâ <strong>first-service</strong></li><li><strong>spring.kafka.properties.sasl.mechanism</strong>: <em>PLAIN</em> üëâ <em>PLAIN</em> (also known as <em>SASL/PLAIN</em>) is a simple username/password authentication mechanism that is typically used with TLS for encryption to implement secure authentication.</li><li><strong>spring.kafka.properties.security.protocol</strong>: <em>SASL_SSL</em> üëâ this property ensures that all broker/client communication is encrypted and authenticated using <em>SASL/PLAIN</em></li><li><strong>spring.kafka.properties.sasl.jaas.config</strong>: Configure the JAAS configuration property to describe how the clients like producer and consumer can connect to the Kafka Brokers. The properties username and password are used by clients to configure the user for client connections. In our example, clients connect to the broker as <strong>the username is &ldquo;$ConnectionString&rdquo;</strong> and <strong>the password will be our Azure EventHubs ConnectionString</strong> which is in our case the connection string of our <strong>Shared Access Authorization Policy</strong>. We will be using <strong>org.apache.kafka.common.security.plain.PlainLoginModule</strong> as the login module implementation which should provide username as the public credential and password as the private credential üëâ so our property value will be: <em>org.apache.kafka.common.security.plain.PlainLoginModule required username="$ConnectionString" password=&ldquo;Endpoint=sb://nebrass.servicebus.windows.net/;SharedAccessKeyName=SendReceiveOnly;SharedAccessKey=XXXX&rdquo;;</em></li><li><strong>spring.kafka.producer.value-serializer</strong>: Serializer class for values üëâ <em>com.targa.labs.dev.kafkaonazure.ProducerMessageSerializer</em></li></ul><h2 id=expose-the-kafka-producer>Expose the kafka producer<a hidden class=anchor aria-hidden=true href=#expose-the-kafka-producer>#</a></h2><p>We will be inserting Kafka messages with a content received from a <strong>REST API</strong>. So for this, we will create a new <strong>RestController</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span>
</span></span><span class=line><span class=cl><span class=nd>@RequestMapping</span><span class=o>(</span><span class=s>&#34;/api&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nd>@RequiredArgsConstructor</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KafkaSender</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>KafkaProducer</span> <span class=n>kafkaProducer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@PostMapping</span><span class=o>(</span><span class=s>&#34;send&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendData</span><span class=o>(</span><span class=nd>@RequestBody</span> <span class=n>SimpleMessage</span> <span class=n>message</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>kafkaProducer</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>message</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>We can send some messages using Postman/Insomnia or even via command line, for example, using cURL:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -d <span class=s1>&#39;{&#34;body&#34;: &#34;Hello there !&#34;}&#39;</span> -H <span class=s2>&#34;Content-Type: application/json&#34;</span> -X POST http://localhost:8080/api/send
</span></span></code></pre></td></tr></table></div></div><h2 id=creating-the-kafka-consumer>Creating the Kafka consumer<a hidden class=anchor aria-hidden=true href=#creating-the-kafka-consumer>#</a></h2><p>The same way we did the Kafka Producer, our Kafka Consumer will be a classic Spring Service with a method annotated with @KafkaListener on our Event Hub:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Service</span>
</span></span><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KafkaConsumer</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@KafkaListener</span><span class=o>(</span><span class=n>topics</span> <span class=o>=</span> <span class=s>&#34;${topic.name}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>receive</span><span class=o>(</span><span class=n>SimpleMessage</span> <span class=n>consumerMessage</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;Received message from kafka queue: {}&#34;</span><span class=o>,</span> <span class=n>consumerMessage</span><span class=o>.</span><span class=na>getBody</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>So simple ! üòÅ but this will not be working, unless we add the <strong>Spring Kafka Consumer</strong> configuration in our <code>application.yaml</code> file:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spring</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>kafka</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>consumer</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>group-id</span><span class=p>:</span><span class=w> </span><span class=l>$Default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>spring.json</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>use.type.headers</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>value.default.type</span><span class=p>:</span><span class=w> </span><span class=l>com.targa.labs.dev.kafkaonazure.SimpleMessage</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The listed configuration is:</p><ul><li><strong>spring.kafka.consumer.group-id</strong>: required and unique string that identifies the consumer group this consumer belongs to. üëâ in our case it will be <strong>$Default</strong> to use the basic consumer group that was created when we created our <strong>Azure Event Hub</strong>.</li><li><strong>spring.kafka.consumer.properties.spring.json.use.type.headers</strong>: to prevent the Consumer even looking for headers üëâ in our case it will be <strong>false</strong></li><li><strong>spring.kafka.consumer.properties.spring.json.value.default.type</strong>: the message to be consumed üëâ <strong>com.microsoft.cse.labs.kafkaeventhub.SimpleMessage</strong></li></ul><p>Cool ! Now our application will be producing a message to the Azure Event Hub, and it will be receiving it as soon as it is available üòÅ the final diagram of our ecosystem is:</p><p><img loading=lazy src=../images/azure-eventhubs-kafka-app-diagram-1024x211.webp alt="Azure Event Hubs with our Kafka Application" title="Azure Event Hubs with our Kafka Application"></p><h2 id=final-words>Final words<a hidden class=anchor aria-hidden=true href=#final-words>#</a></h2><p>As you can see in our application, we don&rsquo;t have any specific library or connector of <strong>Azure</strong>. We are developing a plain <strong>Spring Kafka</strong> application and we are just plugging it to <strong>Azure Event Hubs</strong> instead of <strong>a classic Kafka broker</strong>. The facility of developing without any constraints of the <strong>target broker</strong> is a huge add-on for the customers willing to move their applications to <strong>Azure Event Hubs</strong>. This abstraction and portability is one of the most wanted facility of the <strong>Java EE specifications</strong>, such as the abstraction for the JPA specification and the ability to be plugged to any Relational DBMS.</p></div><footer class=post-footer><ul class=post-tags></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Playing with Spring Boot and Kafka on Azure Event Hub on twitter" href="https://twitter.com/intent/tweet/?text=Playing%20with%20Spring%20Boot%20and%20Kafka%20on%20Azure%20Event%20Hub&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with Spring Boot and Kafka on Azure Event Hub on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f&title=Playing%20with%20Spring%20Boot%20and%20Kafka%20on%20Azure%20Event%20Hub&summary=Playing%20with%20Spring%20Boot%20and%20Kafka%20on%20Azure%20Event%20Hub&source=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with Spring Boot and Kafka on Azure Event Hub on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f&title=Playing%20with%20Spring%20Boot%20and%20Kafka%20on%20Azure%20Event%20Hub"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with Spring Boot and Kafka on Azure Event Hub on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with Spring Boot and Kafka on Azure Event Hub on whatsapp" href="https://api.whatsapp.com/send?text=Playing%20with%20Spring%20Boot%20and%20Kafka%20on%20Azure%20Event%20Hub%20-%20https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Playing with Spring Boot and Kafka on Azure Event Hub on telegram" href="https://telegram.me/share/url?text=Playing%20with%20Spring%20Boot%20and%20Kafka%20on%20Azure%20Event%20Hub&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-spring-boot-and-kafka-on-azure-event-hub%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.nebrass.fr>Nebrass Homepage</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>