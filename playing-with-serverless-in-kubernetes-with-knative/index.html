<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Playing with Serverless in Kubernetes with Knative | Nebrass Homepage</title>
<meta name=keywords content>
<meta name=description content="The serverless architecture became one of the most buzzy words nowadays. Almost all the cloud providers have a Serverless platforms in their catalogues:
 Microsoft Azure Functions Amazon Web Services Lambda Google Cloud Functions IBM Cloud Functions Oracle Functions  In an other world, there are many solutions to have a Serverless Runtime into Kubernetes, which is the most popular (and the most wonderful) container orchestrator in the market. These solutions are so helpful especially if you need portability for your functions.">
<meta name=author content>
<link rel=canonical href=https://blog.nebrass.fr/playing-with-serverless-in-kubernetes-with-knative/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9aeab43847eb11aca320bfadedfe191ed6516dd768bf1314b534c4992aac901a.css integrity="sha256-muq0OEfrEayjIL+t7f4ZHtZRbddovxMUtTTEmSqskBo=" rel="preload stylesheet" as=style>
<script src=/js/prism.min.js></script>
<link rel=stylesheet href=/css/prism.min.css>
<link rel=icon href=https://blog.nebrass.fr/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.nebrass.fr/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.nebrass.fr/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.nebrass.fr/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.nebrass.fr/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<style amp-custom>.main,.footer,.nav{max-width:calc(var(--main-width) + var(--gap) * 15)}</style>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-111781986-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Playing with Serverless in Kubernetes with Knative">
<meta property="og:description" content="The serverless architecture became one of the most buzzy words nowadays. Almost all the cloud providers have a Serverless platforms in their catalogues:
 Microsoft Azure Functions Amazon Web Services Lambda Google Cloud Functions IBM Cloud Functions Oracle Functions  In an other world, there are many solutions to have a Serverless Runtime into Kubernetes, which is the most popular (and the most wonderful) container orchestrator in the market. These solutions are so helpful especially if you need portability for your functions.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.nebrass.fr/playing-with-serverless-in-kubernetes-with-knative/">
<meta property="og:image" content="https://blog.nebrass.fr/images/playing-with-serverless-k8s-knative.webp"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-11-28T00:00:00+00:00">
<meta property="article:modified_time" content="2019-11-28T00:00:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.nebrass.fr/images/playing-with-serverless-k8s-knative.webp">
<meta name=twitter:title content="Playing with Serverless in Kubernetes with Knative">
<meta name=twitter:description content="The serverless architecture became one of the most buzzy words nowadays. Almost all the cloud providers have a Serverless platforms in their catalogues:
 Microsoft Azure Functions Amazon Web Services Lambda Google Cloud Functions IBM Cloud Functions Oracle Functions  In an other world, there are many solutions to have a Serverless Runtime into Kubernetes, which is the most popular (and the most wonderful) container orchestrator in the market. These solutions are so helpful especially if you need portability for your functions.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.nebrass.fr/posts/"},{"@type":"ListItem","position":3,"name":"Playing with Serverless in Kubernetes with Knative","item":"https://blog.nebrass.fr/playing-with-serverless-in-kubernetes-with-knative/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Playing with Serverless in Kubernetes with Knative","name":"Playing with Serverless in Kubernetes with Knative","description":"The serverless architecture became one of the most buzzy words nowadays. Almost all the cloud providers have a Serverless platforms in their catalogues:\n Microsoft Azure Functions Amazon Web Services Lambda Google Cloud Functions IBM Cloud Functions Oracle Functions  In an other world, there are many solutions to have a Serverless Runtime into Kubernetes, which is the most popular (and the most wonderful) container orchestrator in the market. These solutions are so helpful especially if you need portability for your functions.","keywords":[],"articleBody":"The serverless architecture became one of the most buzzy words nowadays. Almost all the cloud providers have a Serverless platforms in their catalogues:\n Microsoft Azure Functions Amazon Web Services Lambda Google Cloud Functions IBM Cloud Functions Oracle Functions  In an other world, there are many solutions to have a Serverless Runtime into Kubernetes, which is the most popular (and the most wonderful) container orchestrator in the market. These solutions are so helpful especially if you need portability for your functions. For example, you can have the same Serverless Runtime deployed to Azure Kubernetes Service and Google Kubernetes Engine. You can be deploying the same binaries as functions identically to both of the cloud providers.\nIn this tutorial, I will demonstrate how to deploy a Serverless Framework¬†to Minikube and on which we will deploy some Functions based on Spring Boot Framework.\nThere are many serverless runtimes for Kubernetes:\n Kubeless Knative Fission OpenFaas OpenWhisk Fn Project and maybe there is an other framework that appears while I‚Äôm writing this post üòÅ  For this first tutorial, I will choose Knative üòÑ\nWhat is Knative? Based on the Knative Documentation:\n Knative extends Kubernetes to provide a set of middleware components that are essential to build modern, source-centric, and container-based applications that can run anywhere: on premises, in the cloud, or even in a third-party data center.\nEach of the components under the Knative project attempt to identify common patterns and codify the best practices that are shared by successful, real-world, Kubernetes-based frameworks and applications.\nDevelopers on Knative can use familiar idioms, languages, and frameworks to deploy functions, applications, or containers workloads.\n The shortest definition that I like for Knative: a platform to build and run Serverless applications on Kubernetes:\n The Build features are offered via a set of building blocks for creating container images from source code. ‚ö†Ô∏è‚ö†Ô∏è Before the v0.8, Knative had its own Build component. Since the v0.8, Knative Build is deprecated in favor of Tekton üê±¬†‚ö†Ô∏è‚ö†Ô∏è The Run features are provided via two high level components:  Serving provides the possibility to deploy and serving functions and serverless applications. It includes automatic scale-to-zero function. Knative‚Äôs Serve component offers two important features for container management.:  The first feature is multiple-configuration: offers the ability to create different versions of the same container-based service and run them concurrently, and this is where the other feature of its serving component comes into play. The second feature is¬†service routing: offers the ability to do A/B Testing: route a subset of our users to the new version of service, while keeping the rest of the users routed to the old version. This process is helpful to ensure that the new version has no killers before totally migrating to it üòÅ   Eventing provides blocks for defining, consuming and producing events to bind event sources to services. This component define also the triggering actions based on them within a cloud-native environment.    To ensure the Serving \u0026 Eventing, Knative is based on the powerful Istio Service Mesh features to expose, monitor, control the services and to encrypt the transiting data.\nThe Knative high-level ecosystem looks like:\nKnative high-level ecosystem\n What‚Äôs this kitty looking to the deprecated Build component ? This is actually Tekton.\nTekton does not belong to Knative as internal component, but it‚Äôs adopted by Knative as its recommended CI/CD pipelines.\nI will be covering Tekton Pipelines¬†in a dedicated tutorial. Stay tuned üìªüé∂üòÅ\nWhy Knative ? Knative is an source platform developed and supported by very big companies like IBM, Google, Pivotal‚Ä¶ Knative is designed and developed based of the needs and the latest standards of the market. It is mainly developer focused, this is why all the features are developer friendly. With Knative, developers will be focusing only on implementing the business logic in the source code and avoid them the waste of effort/time related to building, deploying and managing the environment, which is the core principle of the serverless architecture. The key part is to package the code in Containers that can be deployed to Kubernetes via the Knative pipelines.\nWith the integration with Kubernetes, Knative boosts its position by adopting Istio as core Service Mesh solution.\nNow, let‚Äôs move to the practical part of this post.\nInstalling the requirements of Knative Knative requires the having a Kubernetes cluster with Istio Service Mesh deployed ü§ì\nI will be using Minikube as local Kubernetes cluster.\nConfiguring Minikube So, we will start by configuring Minikube. I suppose that you already installed the VM Driver and Minikube binaries for your OS ü•≥\nWe will start by creating a new minikube profile:\n1  $ minikube profile knative   Next, we will start the minikube with our custom configuration:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ minikube start --memory=8192 --cpus=6 \\  --kubernetes-version=v1.14.0 \\  --vm-driver=hyperkit \\  --disk-size=30g \\  --extra-config=apiserver.enable-admission-plugins=\"LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook\" üòÑ [knative] minikube v1.5.2 on Darwin 10.15.1 üî• Creating hyperkit VM (CPUs=6, Memory=8192MB, Disk=30000MB) ... üê≥ Preparing Kubernetes v1.14.0 on Docker '18.09.9' ... ‚ñ™ apiserver.enable-admission-plugins=LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook üöú Pulling images ... üöÄ Launching Kubernetes ... ‚åõ Waiting for: apiserver üèÑ Done! kubectl is now configured to use \"knative\"   Now, we need to install Istio Service Mesh on our Minikube cluster üòÅ\nInstalling Istio This tutorial will cover the installation of Istio v1.1.7.\nDownloading Istio and installing Custom resources definitions   Download Istio Service Mesh files:\n1 2 3  $ export ISTIO_VERSION=1.1.7 $ curl -L https://git.io/getLatestIstio | sh - $ cd istio-${ISTIO_VERSION}     We will install the Istio CRDs:\n1  $ for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done     Now, we need to create a namespace with a label istio-injection: disabled. To do that:\n1 2  $ kubectl create ns istio-system $ kubectl label ns istio-system istio-injection=disabled     Now we will proceed to install Istio without Sidecar Injection, which is the recommended default installation ü•≥ We need to build the resources file based on the template :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  $ helm template --namespace=istio-system \\  --set prometheus.enabled=false \\  --set mixer.enabled=false \\  --set mixer.policy.enabled=false \\  --set mixer.telemetry.enabled=false \\  `# Pilot doesn't need a sidecar.` \\ --set pilot.sidecar=false \\  --set pilot.resources.requests.memory=128Mi \\  `# Disable galley (and things requiring galley).` \\ --set galley.enabled=false \\  --set global.useMCP=false \\  `# Disable security / policy.` \\ --set security.enabled=false \\  --set global.disablePolicyChecks=true \\  `# Disable sidecar injection.` \\ --set sidecarInjectorWebhook.enabled=false \\  --set global.proxy.autoInject=disabled \\  --set global.omitSidecarInjectorConfigMap=true \\  --set gateways.istio-ingressgateway.autoscaleMin=1 \\  --set gateways.istio-ingressgateway.autoscaleMax=2 \\  `# Set pilot trace sampling to 100%` \\ --set pilot.traceSampling=100 \\  install/kubernetes/helm/istio \\   ./istio-minimal.yaml     The final step will be to create the resources based on the generated file:\n1  $ kubectl apply -f istio-minimal.yaml     Now, we need to verify that everything is working fine :\n1  $ kubectl get pods --namespace istio-system   The output will looks like:\n1 2 3  NAME READY STATUS RESTARTS AGE istio-ingressgateway-57dfd8fd67-gf27c 1/1 Running 0 112m istio-pilot-6fb7569c86-rhk5n 1/1 Running 0 112m   As everything is working as expected, now we can proceed to install Knative ü•≥\n  Installing the Knative After installing Istio Service Mesh, we will install Knative:\n  As we did for Istio, we need to install the Knative CRDs:\n1 2 3 4  $ kubectl apply --selector knative.dev/crd-install=true \\  --filename https://github.com/knative/serving/releases/download/v0.10.0/serving.yaml \\  --filename https://github.com/knative/eventing/releases/download/v0.10.0/release.yaml \\  --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring.yaml   This command will install these CRDs:\n apiserversources.sources.eventing.knative.dev brokers.eventing.knative.dev certificates.networking.internal.knative.dev channels.messaging.knative.dev configurations.serving.knative.dev containersources.sources.eventing.knative.dev cronjobsources.sources.eventing.knative.dev eventtypes.eventing.knative.dev images.caching.internal.knative.dev ingresses.networking.internal.knative.dev inmemorychannels.messaging.knative.dev metrics.autoscaling.internal.knative.dev parallels.messaging.knative.dev podautoscalers.autoscaling.internal.knative.dev revisions.serving.knative.dev routes.serving.knative.dev sequences.messaging.knative.dev serverlessservices.networking.internal.knative.dev services.serving.knative.dev subscriptions.messaging.knative.dev triggers.eventing.knative.dev    We need to install Knative and all its dependencies now:\n1 2 3  $ kubectl apply --filename https://github.com/knative/serving/releases/download/v0.10.0/serving.yaml \\  --filename https://github.com/knative/eventing/releases/download/v0.10.0/release.yaml \\  --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring.yaml   These commands will create 245 resources ü§™ divised like:\n 3 Namespaces 37 ClusterRole 14 ServiceAccount 17 ClusterRoleBinding 8 RBAC Role 6 RoleBinding 21 CRDs 32 ConfigMaps 15 Deployment 15 ReplicaSet 16 Services 20 Pods 2 StatefulSet 2 DaemonSet 1 HorizontalPodAutoscaler ‚Ä¶    Before moving to the next step, we need to verify that all the pods are running:\n1  $ kubectl get pods --all-namespaces   Now that your cluster has Knative installed, you‚Äôre ready to deploy an app. üòÅ\n  PREPARING OUR SAMPLE APPLICATION We will generate a new Spring Boot application with the Web dependency. We will create a new RestController:\n1 2 3 4 5 6 7 8 9  @RestController @RequestMapping(\"/api\") public class HelloController { @GetMapping(\"/hello\") public String sayHello() { return \"Hello Nebrass ! it's \" + System.currentTimeMillis(); } }   Now, I will package this beautiful application üòú in a Docker üê≥ container. I will be using the great Google Jib Maven plugin. To do that I will add the plugin in the build section of the pom.xml:\n1 2 3 4 5 6 7 8 9 10 11   com.google.cloud.tools jib-maven-plugin 1.8.0   docker.io/nebrass/${project.artifactId}:${project.version} osxkeychain      The credHelper section will tell the plugin to get my Docker Hub credentials from the Mac OS Keychain, where I stored them üòÅ for sure I will not be happy to share them üòú\nLet‚Äôs build the project now:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  $ mvn compile jib:build This command will compile, build and push the container to **Docker Hub**. The **Jib** build log will look like: [INFO] [INFO] --- jib-maven-plugin:1.8.0:build (default-cli) @ spring-knative-application --- [INFO] [INFO] Containerizing application to nebrass/spring-knative-application:0.0.1-SNAPSHOT... [WARNING] Base image 'gcr.io/distroless/java:8' does not use a specific image digest - build may not be reproducible [INFO] Using base image with digest: sha256:a13ac1ce516ec5e49ae9dfd3b8183e9e8328180a65757d454e594a9ce6d1e35d [INFO] [INFO] Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, com.targa.labs.dev.knative.SpringKubelessApplication] [INFO] [INFO] Built and pushed image as nebrass/spring-knative-application:0.0.1-SNAPSHOT [INFO] Executing tasks: [INFO] [=========================== ] 90,0% complete [INFO]  launching layer pushers [INFO]   Good ! But this is an over engineered solution for our minikube proof-of-concept. Instead, we can use the minikube local Docker registry. The Jib plugin configuration will look like:\n1 2 3 4 5 6 7 8 9 10   com.google.cloud.tools jib-maven-plugin 1.8.0   nebrass/${project.artifactId}:${project.version}      Before building the Docker container, don‚Äôt forget to map the environment to the minikube local environment:\n1 2 3  $ eval $(minikube docker-env) $ mvn compile jib:dockerBuild   Now, the container will be built in the local Docker daemon and pushed into the minikube local registry.\nNow, we need to create a Knative Service (aka ksvc). The ksvc definition file looks like:\n1 2 3 4 5 6 7 8 9  apiVersion:serving.knative.dev/v1kind:Servicemetadata:name:spring-knative-applicationspec:template:spec:containers:- image:nebrass/spring-knative-application:0.0.1-SNAPSHOT  Now, let‚Äôs create the ksvc resource from the this ksvc.yaml file:\n1  $ kubectl apply -f ksvc.yaml   Now that our KService is created, Knative will perform the following steps:\n Create a new immutable revision for this version of the app. Network programming to create a route, ingress, service, and load balancer for our app. Automatically scale our pods up and down (including to zero active pods).  To check the listing of the KServices:\n1 2 3 4  $ kubectl get ksvc NAME URL LATESTCREATED LATESTREADY READY REASON spring-knative-application http://spring-knative-application.default.example.com spring-knative-application-h4w27 spring-knative-application-h4w27 True   The URL section is the one that interests us now: http://spring-knative-application.default.example.com\nWe will be using this value for consuming our KService. But before, we need to get the Istio Ingress Gateway IP address and port:\n1 2 3  $ export IP_ADDRESS=$(minikube ip):$(kubectl get svc istio-ingressgateway \\  --namespace istio-system \\  --output 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')   In Knative, KService is reachable on:\nKnative KService access path\n We can for example access the /api/hello REST API on our spring-knative-application ksvc via curl :\n1  $ curl -H \"Host: spring-knative-application.default.example.com\" $IP_ADDRESS/api/hello   We can use also httpie, my preferred tool:\n1  $ http $IP_ADDRESS/api/hello 'Host: spring-knative-application.default.example.com'   The request parameters are:\n spring-knative-application.default.example.com: is the URL of our ksvc $IP_ADDRESS: is the Istio Ingress Gateway that we created in the previous step /api/hello: is the URI of our REST Controller that we created in our sample Spring Boot Application  Magically, we will get a response like :\nHello Nebrass ! it's 1574799175389\nü§©ü•≥ü§©ü•≥ WaaaaaYY ü§©ü•≥ü§©ü•≥\nbehind the scenes - how things work ? Our application is served by the KNative Serving component (wow obviously üòÖ).. so let‚Äôs go deep in the KNative Serving.\nLet‚Äôs start with some theories ü§ì This definitionsüëáüëá are grabbed from the official Knative documentation üëáüëá I made some modificatiosn\nKnative Serving defines a set of objects as Kubernetes Custom Resource Definitions (CRDs). These objects are used to define and control how your serverless workload behaves on the cluster:\n Service: The¬†service.serving.knative.dev¬†resource automatically manages the whole lifecycle of your workload. It controls the creation of other objects to ensure that your app has a route, a configuration, and a new revision for each update of the service. Service can be defined to always route traffic to the latest revision or to a pinned revision. Route: The¬†route.serving.knative.dev resource maps a network endpoint to one or more revisions. You can manage the traffic in several ways, including fractional traffic and named Routes. Configuration: The¬†configuration.serving.knative.dev resource maintains the desired state for your deployment. It provides a clean separation between code and configuration and follows the 12Factor App methodology. Modifying a configuration creates a new revision. This is a very big point in KNative: REVISIONS ARE IMMUTABLE. Revision: The¬†revision.serving.knative.dev resource is a point-in-time snapshot of the code and configuration for each modification made to the workload. AGAIN: Revisions are immutable objects and can be retained for as long as useful. Knative Serving Revisions can be automatically scaled up and down according to incoming traffic.  Knative Serving diagram\n This is the theory, but what‚Äôs happening in our case ? üòÅ\nThe Knative Serving diagram of our use case his:\nThe Knative Serving Ecosystem for our use case\n What‚Äôs this Autoscaler and Activator? üò±üò±\nThe Autoscaler \u0026 Activator are the two main components used by Knative to:\n handle elasticity of Pods to handle the high load of requests scale down to zero when there is not active request üòÅ Don‚Äôt forget, the idea behind the Serverless is to have no active resource in the IDLE status ü§ë  The Autoscaler \u0026 Activator appear in the cluster as Pods running in the knative-serving namespace:\n The Autoscaler collects information about the number of concurrent requests to a Revision, through a container called the queue-proxy running inside the Revision‚Äôs Pod that already runs an other container called user-provided which is our spring-knative-application image. The Autoscaler, based on the number of requests, will increase or decrease the number of desired replicas in the Revision related Deployment. The Activator is a component that receives all the traffic coming to the IDLE Revisions. When the Activator receives a request, it¬†changes the Revision state to Active, which lets the Revision Pods receive the requests.  Playing with Logs, metrics and traces on Knative Knative logs In the KNative world, we have a (very) common Kubernetes logging pattern offered by the EFK brothers üòÅ no, seriously, no it‚Äôs the EFK Band ü§©\n Elasticsearch is a distributed, RESTful search and analytics engine. Fluentd is an Logs collector - alternative for Logstash and more suitable for Containers. Kibana most used Elasticsearch data visualization engine.  Cool ! But we need to enable the EFK Logging in our KNative cluster: To do that we need to some configuration and some installations.\n  We need to edit the config-observability ConfigMap stored in the knative-serving Namespace:\n1  $ kubectl edit cm -n knative-serving config-observability     Now, under the data section add this entry:\n1 2 3 4 5 6  logging.request-log-template: '{\"httpRequest\": {\"requestMethod\": \"{{.Request.Method}}\", \"requestUrl\": \"{{js .Request.RequestURI}}\", \"requestSize\": \"{{.Request.ContentLength}}\", \"status\": {{.Response.Code}}, \"responseSize\": \"{{.Response.Size}}\", \"userAgent\": \"{{js .Request.UserAgent}}\", \"remoteIp\": \"{{js .Request.RemoteAddr}}\", \"serverIp\": \"{{.Revision.PodIP}}\", \"referer\": \"{{js .Request.Referer}}\", \"latency\": \"{{.Response.Latency}}s\", \"protocol\": \"{{.Request.Proto}}\"}, \"traceId\": \"{{index .Request.Header \"X-B3-Traceid\"}}\"}'   Be careful about the spaces, the ConfigMap will look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  apiVersion:v1data:...logging.request-log-template:'{\"httpRequest\": {\"requestMethod\": \"{{.Request.Method}}\", \"requestUrl\": \"{{js .Request.RequestURI}}\", \"requestSize\": \"{{.Request.ContentLength}}\", \"status\": {{.Response.Code}}, \"responseSize\": \"{{.Response.Size}}\", \"userAgent\": \"{{js .Request.UserAgent}}\", \"remoteIp\": \"{{js .Request.RemoteAddr}}\", \"serverIp\": \"{{.Revision.PodIP}}\", \"referer\": \"{{js .Request.Referer}}\", \"latency\": \"{{.Response.Latency}}s\", \"protocol\": \"{{.Request.Proto}}\"}, \"traceId\": \"{{index .Request.Header \"X-B3-Traceid\"}}\"}'kind:ConfigMapmetadata:annotations:kubectl.kubernetes.io/last-applied-configuration:|{\"apiVersion\":\"v1\",\"data\":{\"_example\":\"... creationTimestamp: \"2019-11-27T13:53:51Z\" labels: serving.knative.dev/release: v0.10.0 name: config-observability namespace: knative-serving resourceVersion: \"5058\"selfLink:/api/v1/namespaces/knative-serving/configmaps/config-observabilityuid:57a86288-111d-11ea-ba80-2659da8acb87    Install the ELK Stack:\n1  $ kubectl apply --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring-logs-elasticsearch.yaml     Before going to the next steps, verify that all the pods are running:\n1  $ kubectl get pods --namespace knative-monitoring --watch     We need to to ensure that the Fluentd DaemonSet runs on all our nodes via labeling the nodes with the beta.kubernetes.io/fluentd-ds-ready=true¬†label:\n1  $ kubectl label nodes --all beta.kubernetes.io/fluentd-ds-ready=\"true\"     Run the following command to ensure that the fluentd-ds DaemonSet is ready on at least one node:\n1  $ kubectl get daemonset fluentd-ds --namespace knative-monitoring --watch     Now, we will start a local Kubernetes proxy:\n1  $ kubectl proxy     Next, access the Kibana via the URL: http://localhost:8001/api/v1/namespaces/knative-monitoring/services/kibana-logging/proxy/app/kibana\n  Now, the first step is the configure an index pattern:\n Index pattern: logstash-* Time Filter field name: @timestamp  Kibana - Create index pattern\n   Now, click on the Discover menu, and in the search menu, we will enter the name of our KNative Service: spring-knative-application\nKibana - Searching KNative Service logging\n Have fun ! ü•≥üòçü§©\n  Knative metrics On KNative, we access metrics through the Grafana UI, which is the visualization tool for Prometheus.\n‚ö†Ô∏è If you are not used to Grafana and Prometheus, I highly recommend this great free course üòé Nowadays, mastering Grafana and Prometheus is a highly recommended skill for any Kubernetes professional.\nhttps://www.youtube.com/watch?v=bErGEHf6GCc\u0026list=PLpbcUe4chE7-HuslXKj1MB10ncorfzEGa\nTo open the KNative¬†Grafana UI, enter the following command:\n1 2 3 4  $ kubectl port-forward --namespace knative-monitoring \\  $(kubectl get pods --namespace knative-monitoring \\  --selector=app=grafana \\  --output=jsonpath=\"{.items..metadata.name}\") 3000   Now, the Grafana UI is reachable via the URL: http://localhost:3000:\nGrafana UI: Knative Serving - Control Plane Efficiency dashboard\n The following dashboards are pre-installed with KNative Serving:\n Revision HTTP Requests:¬†HTTP request count, latency, and size metrics per revision and per configuration Nodes:¬†CPU, memory, network, and disk metrics at node level Pods:¬†CPU, memory, and network metrics at pod level Deployment:¬†CPU, memory, and network metrics aggregated at deployment level Istio, Mixer and Pilot:¬†Detailed Istio mesh, Mixer, and Pilot metrics Kubernetes:¬†Dashboards giving insights into cluster health, deployments, and capacity usage  If you are used to play with Prometheus, keep calm, you will find always your toy. To access Prometheus, run this command:\n1 2 3 4  $ kubectl port-forward -n knative-monitoring \\  $(kubectl get pods -n knative-monitoring \\  --selector=app=prometheus \\  --output=jsonpath=\"{.items[0].metadata.name}\") 9090   Next, access the Prometheus UI via the URL: http://localhost:9090\nPrometheus UI: sample http_request_duration_microseconds¬†graph\n Enjoy ! ü•≥\nKnative Request Tracing We need to enable the support of Zipkin - I will be using Zipkin with in-memory database:\n1  $ kubectl apply --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring-tracing-zipkin-in-mem.yaml   Next, before accessing the Zipkin UI, start local proxy:\n1  $ kubectl proxy   Next, access the Zipkin UI via the URL: http://localhost:8001/api/v1/namespaces/istio-system/services/zipkin:9411/proxy/zipkin/\nNow, click ‚ÄúFind Traces‚Äù to see the latest traces.\nZipkin UI: KNative ksvc requests traces\n To load the requests traces on our KService, just choose:\n istio-ingressgateway as Service Name spring-knative-application-something as Span Name üëâ which is the only instance of our KNative, in case of high load you will find many instances of our ksvc  Click Find Traces to load all the gathered traces.\nIf you check the loaded traces, you can notice that the first request took 4 seconds to be handled, not like all the others that took only some milliseconds only. These traces can demonstrate the heavy cost of the first request. üòÅ\nWhere is The knative eventing ? üòÅ COMING SOON !\n","wordCount":"3210","inLanguage":"en","image":"https://blog.nebrass.fr/images/playing-with-serverless-k8s-knative.webp","datePublished":"2019-11-28T00:00:00Z","dateModified":"2019-11-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nebrass.fr/playing-with-serverless-in-kubernetes-with-knative/"},"publisher":{"@type":"Organization","name":"Nebrass Homepage","logo":{"@type":"ImageObject","url":"https://blog.nebrass.fr/favicon.ico"}}}</script>
</head>
<body id=top>
<script>window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.nebrass.fr accesskey=h title="Nebrass Homepage (Alt + H)">Nebrass Homepage</a>
<span class=logo-switches>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.nebrass.fr/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://blog.nebrass.fr/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://blog.nebrass.fr/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Playing with Serverless in Kubernetes with Knative
</h1>
<div class=post-meta><span title="2019-11-28 00:00:00 +0000 UTC">November 28, 2019</span>&nbsp;¬∑&nbsp;16 min
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://blog.nebrass.fr/images/playing-with-serverless-k8s-knative.webp alt>
</figure>
<div class=post-content><p>The <a href=https://blog.nebrass.fr/playing-with-serverless-architecture/><strong>serverless architecture</strong></a> became one of the most buzzy words nowadays. Almost all the cloud providers have a <strong>Serverless</strong> platforms in their catalogues:</p>
<ul>
<li><strong>Microsoft</strong> Azure Functions</li>
<li><strong>Amazon</strong> Web Services Lambda</li>
<li><strong>Google</strong> Cloud Functions</li>
<li><strong>IBM</strong> Cloud Functions</li>
<li><strong>Oracle</strong> Functions</li>
</ul>
<p>In an other world, there are many solutions to have a <strong>Serverless Runtime</strong> into <strong>Kubernetes</strong>, which is the most popular (and the most wonderful) container orchestrator in the market. These solutions are so helpful especially if you need portability for your functions. For example, you can have the same <strong>Serverless Runtime</strong> deployed to <strong>Azure Kubernetes Service</strong> and <strong>Google Kubernetes Engine</strong>. You can be deploying the same binaries as functions identically to both of the cloud providers.</p>
<p>In this tutorial, I will demonstrate how to deploy a <strong>Serverless Framework</strong>¬†to <strong>Minikube</strong> and on which we will deploy some <strong>Functions</strong> based on <strong>Spring Boot Framework</strong>.</p>
<p>There are many <strong>serverless runtimes</strong> for <strong>Kubernetes</strong>:</p>
<ul>
<li>Kubeless</li>
<li>Knative</li>
<li>Fission</li>
<li>OpenFaas</li>
<li>OpenWhisk</li>
<li>Fn Project</li>
<li>and maybe there is an other framework that appears while I&rsquo;m writing this post üòÅ</li>
</ul>
<p>For this first tutorial, I will choose <strong>Knative</strong> üòÑ</p>
<h2 id=what-is-knative>What is Knative?<a hidden class=anchor aria-hidden=true href=#what-is-knative>#</a></h2>
<p>Based on the <a href=https://knative.dev/docs/>Knative Documentation</a>:</p>
<blockquote>
<p>Knative extends Kubernetes to provide a set of middleware components that are essential to build modern, source-centric, and container-based applications that can run anywhere: on premises, in the cloud, or even in a third-party data center.</p>
<p>Each of the components under the Knative project attempt to identify common patterns and codify the best practices that are shared by successful, real-world, Kubernetes-based frameworks and applications.</p>
<p>Developers on Knative can use familiar idioms, languages, and frameworks to deploy functions, applications, or containers workloads.</p>
</blockquote>
<p>The shortest definition that I like for Knative: a <strong>platform</strong> to <strong>build</strong> and <strong>run Serverless applications</strong> on <strong>Kubernetes:</strong></p>
<ul>
<li>The <strong>Build</strong> features are offered via a set of building blocks for creating container images from source code. ‚ö†Ô∏è‚ö†Ô∏è Before the <strong>v0.8</strong>, <strong>Knative</strong> had its own <strong>Build</strong> component. Since the <strong>v0.8</strong>, <strong>Knative Build</strong> is deprecated in favor of <strong><a href=https://tekton.dev/>Tekton</a> üê±</strong>¬†‚ö†Ô∏è‚ö†Ô∏è</li>
<li>The <strong>Run</strong> features are provided via two high level components:
<ul>
<li><strong>Serving</strong> provides the possibility to deploy and serving functions and serverless applications. It includes automatic scale-to-zero function. Knative&rsquo;s Serve component offers two important features for container management.:
<ul>
<li>The first feature is <strong>multiple-configuration</strong>: offers the ability to create different versions of the same container-based service and run them concurrently, and this is where the other feature of its serving component comes into play.</li>
<li>The second feature is¬†<strong>service routing</strong>: offers the ability to do A/B Testing: route a subset of our users to the new version of service, while keeping the rest of the users routed to the old version. This process is helpful to ensure that the new version has no killers before totally migrating to it üòÅ</li>
</ul>
</li>
<li><strong>Eventing</strong> provides blocks for defining, consuming and producing events to bind event sources to services. This component define also the triggering actions based on them within a cloud-native environment.</li>
</ul>
</li>
</ul>
<p>To ensure the <strong>Serving</strong> & <strong>Eventing</strong>, <strong>Knative</strong> is based on the powerful <strong><a href=https://blog.nebrass.fr/playing-with-istio-service-mesh-on-kubernetes/>Istio Service Mesh</a></strong> features to <strong>expose</strong>, <strong>monitor</strong>, <strong>control</strong> the <strong>services</strong> and to <strong>encrypt</strong> the transiting <strong>data</strong>.</p>
<p>The <strong>Knative</strong> high-level ecosystem looks like:</p>
<div align=center>
<p><img loading=lazy src=../images/KnativeArchitecture-943x1024.webp alt="Knative high-level ecosystem" title="Knative high-level ecosystem">
Knative high-level ecosystem</p>
</div>
<p>What&rsquo;s this kitty looking to the deprecated Build component ? This is actually <a href=https://tekton.dev/><strong>Tekton</strong></a>.</p>
<p><a href=https://tekton.dev/><strong>Tekton</strong></a> does not belong to <strong>Knative</strong> as internal component, but it&rsquo;s adopted by <strong>Knative</strong> as its recommended CI/CD pipelines.</p>
<p>I will be covering <a href=https://tekton.dev/><strong>Tekton Pipelines</strong></a>¬†in a dedicated tutorial. Stay tuned üìªüé∂üòÅ</p>
<h2 id=why-knative->Why Knative ?<a hidden class=anchor aria-hidden=true href=#why-knative->#</a></h2>
<p>Knative is an source platform developed and supported by very big companies like IBM, Google, Pivotal&mldr; Knative is designed and developed based of the needs and the latest standards of the market. It is mainly developer focused, this is why all the features are developer friendly. With Knative, developers will be focusing only on implementing the business logic in the source code and avoid them the waste of effort/time related to building, deploying and managing the environment, which is <a href=https://blog.nebrass.fr/playing-with-serverless-architecture/>the core principle of the serverless architecture</a>. The key part is to package the code in Containers that can be deployed to Kubernetes via the Knative pipelines.</p>
<p>With the integration with Kubernetes, Knative boosts its position by adopting Istio as core Service Mesh solution.</p>
<p>Now, let&rsquo;s move to the practical part of this post.</p>
<h2 id=installing-the-requirements-of-knative>Installing the requirements of Knative<a hidden class=anchor aria-hidden=true href=#installing-the-requirements-of-knative>#</a></h2>
<p><strong>Knative</strong> requires the having a <strong>Kubernetes</strong> cluster with <strong>Istio Service Mesh</strong> deployed ü§ì</p>
<p>I will be using <strong>Minikube</strong> as <strong>local Kubernetes cluster</strong>.</p>
<h3 id=configuring-minikube>Configuring Minikube<a hidden class=anchor aria-hidden=true href=#configuring-minikube>#</a></h3>
<p>So, we will start by configuring <strong>Minikube</strong>. I suppose that you already installed the <strong>VM Driver</strong> and <strong>Minikube</strong> binaries for your OS ü•≥</p>
<p>We will start by creating a new <code>minikube</code> profile:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ minikube profile knative
</code></pre></td></tr></table>
</div>
</div><p>Next, we will start the <strong>minikube</strong> with our custom configuration:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ minikube start --memory<span class=o>=</span><span class=m>8192</span> --cpus<span class=o>=</span><span class=m>6</span> <span class=se>\
</span><span class=se></span>  --kubernetes-version<span class=o>=</span>v1.14.0 <span class=se>\
</span><span class=se></span>  --vm-driver<span class=o>=</span>hyperkit <span class=se>\
</span><span class=se></span>  --disk-size<span class=o>=</span>30g <span class=se>\
</span><span class=se></span>  --extra-config<span class=o>=</span>apiserver.enable-admission-plugins<span class=o>=</span><span class=s2>&#34;LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook&#34;</span>

üòÑ  <span class=o>[</span>knative<span class=o>]</span> minikube v1.5.2 on Darwin 10.15.1
üî•  Creating hyperkit VM <span class=o>(</span><span class=nv>CPUs</span><span class=o>=</span>6, <span class=nv>Memory</span><span class=o>=</span>8192MB, <span class=nv>Disk</span><span class=o>=</span>30000MB<span class=o>)</span> ...
üê≥  Preparing Kubernetes v1.14.0 on Docker <span class=s1>&#39;18.09.9&#39;</span> ...
    ‚ñ™ apiserver.enable-admission-plugins<span class=o>=</span>LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook
üöú  Pulling images ...
üöÄ  Launching Kubernetes ... 
‚åõ  Waiting <span class=k>for</span>: apiserver
üèÑ  Done! kubectl is now configured to use <span class=s2>&#34;knative&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, we need to install <strong>Istio Service Mesh</strong> on our <strong>Minikube</strong> cluster üòÅ</p>
<h3 id=installing-istio>Installing Istio<a hidden class=anchor aria-hidden=true href=#installing-istio>#</a></h3>
<p>This tutorial will cover the installation of <strong>Istio v1.1.7</strong>.</p>
<h3 id=downloading-istio-and-installing-custom-resources-definitions>Downloading Istio and installing Custom resources definitions<a hidden class=anchor aria-hidden=true href=#downloading-istio-and-installing-custom-resources-definitions>#</a></h3>
<ol>
<li>
<p>Download <strong>Istio Service Mesh</strong> files:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>ISTIO_VERSION</span><span class=o>=</span>1.1.7
$ curl -L https://git.io/getLatestIstio <span class=p>|</span> sh -
$ <span class=nb>cd</span> istio-<span class=si>${</span><span class=nv>ISTIO_VERSION</span><span class=si>}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>We will install the <strong>Istio CRDs</strong>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ <span class=k>for</span> i in install/kubernetes/helm/istio-init/files/crd*yaml<span class=p>;</span> <span class=k>do</span> kubectl apply -f <span class=nv>$i</span><span class=p>;</span> <span class=k>done</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Now, we need to create a namespace with a label <code>istio-injection: disabled</code>. To do that:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl create ns istio-system
$ kubectl label ns istio-system istio-injection<span class=o>=</span>disabled
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Now we will proceed to install <strong>Istio without Sidecar Injection</strong>, which is the <strong>recommended default installation</strong> ü•≥ We need to build the resources file based on the template :</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ helm template --namespace<span class=o>=</span>istio-system <span class=se>\
</span><span class=se></span>  --set prometheus.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set mixer.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set mixer.policy.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set mixer.telemetry.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  <span class=sb>`</span><span class=c1># Pilot doesn&#39;t need a sidecar.` \</span>
  --set pilot.sidecar<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set pilot.resources.requests.memory<span class=o>=</span>128Mi <span class=se>\
</span><span class=se></span>  <span class=sb>`</span><span class=c1># Disable galley (and things requiring galley).` \</span>
  --set galley.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set global.useMCP<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  <span class=sb>`</span><span class=c1># Disable security / policy.` \</span>
  --set security.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set global.disablePolicyChecks<span class=o>=</span><span class=nb>true</span> <span class=se>\
</span><span class=se></span>  <span class=sb>`</span><span class=c1># Disable sidecar injection.` \</span>
  --set sidecarInjectorWebhook.enabled<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>  --set global.proxy.autoInject<span class=o>=</span>disabled <span class=se>\
</span><span class=se></span>  --set global.omitSidecarInjectorConfigMap<span class=o>=</span><span class=nb>true</span> <span class=se>\
</span><span class=se></span>  --set gateways.istio-ingressgateway.autoscaleMin<span class=o>=</span><span class=m>1</span> <span class=se>\
</span><span class=se></span>  --set gateways.istio-ingressgateway.autoscaleMax<span class=o>=</span><span class=m>2</span> <span class=se>\
</span><span class=se></span>  <span class=sb>`</span><span class=c1># Set pilot trace sampling to 100%` \</span>
  --set pilot.traceSampling<span class=o>=</span><span class=m>100</span> <span class=se>\
</span><span class=se></span>  install/kubernetes/helm/istio <span class=se>\
</span><span class=se></span>  &gt; ./istio-minimal.yaml
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The final step will be to create the resources based on the generated file:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl apply -f istio-minimal.yaml
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Now, we need to verify that everything is working fine :</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl get pods --namespace istio-system
</code></pre></td></tr></table>
</div>
</div><p>The output will looks like:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>NAME                                    READY   STATUS    RESTARTS   AGE
istio-ingressgateway-57dfd8fd67-gf27c   1/1     Running   <span class=m>0</span>          112m
istio-pilot-6fb7569c86-rhk5n            1/1     Running   <span class=m>0</span>          112m
</code></pre></td></tr></table>
</div>
</div><p>As everything is working as expected, now we can proceed to install <strong>Knative</strong> ü•≥</p>
</li>
</ol>
<h2 id=installing-the-knative>Installing the Knative<a hidden class=anchor aria-hidden=true href=#installing-the-knative>#</a></h2>
<p>After installing <strong>Istio Service Mesh</strong>, we will install <strong>Knative</strong>:</p>
<ol>
<li>
<p>As we did for Istio, we need to install the Knative CRDs:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl apply --selector knative.dev/crd-install<span class=o>=</span><span class=nb>true</span> <span class=se>\
</span><span class=se></span>   --filename https://github.com/knative/serving/releases/download/v0.10.0/serving.yaml <span class=se>\
</span><span class=se></span>   --filename https://github.com/knative/eventing/releases/download/v0.10.0/release.yaml <span class=se>\
</span><span class=se></span>   --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring.yaml
</code></pre></td></tr></table>
</div>
</div><p>This command will install these CRDs:</p>
<ul>
<li>apiserversources.sources.eventing.knative.dev</li>
<li>brokers.eventing.knative.dev</li>
<li>certificates.networking.internal.knative.dev</li>
<li>channels.messaging.knative.dev</li>
<li>configurations.serving.knative.dev</li>
<li>containersources.sources.eventing.knative.dev</li>
<li>cronjobsources.sources.eventing.knative.dev</li>
<li>eventtypes.eventing.knative.dev</li>
<li>images.caching.internal.knative.dev</li>
<li>ingresses.networking.internal.knative.dev</li>
<li>inmemorychannels.messaging.knative.dev</li>
<li>metrics.autoscaling.internal.knative.dev</li>
<li>parallels.messaging.knative.dev</li>
<li>podautoscalers.autoscaling.internal.knative.dev</li>
<li>revisions.serving.knative.dev</li>
<li>routes.serving.knative.dev</li>
<li>sequences.messaging.knative.dev</li>
<li>serverlessservices.networking.internal.knative.dev</li>
<li>services.serving.knative.dev</li>
<li>subscriptions.messaging.knative.dev</li>
<li>triggers.eventing.knative.dev</li>
</ul>
</li>
<li>
<p>We need to install <strong>Knative</strong> and all its dependencies now:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl apply --filename https://github.com/knative/serving/releases/download/v0.10.0/serving.yaml <span class=se>\
</span><span class=se></span>   --filename https://github.com/knative/eventing/releases/download/v0.10.0/release.yaml <span class=se>\
</span><span class=se></span>   --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring.yaml
</code></pre></td></tr></table>
</div>
</div><p>These commands will create 245 resources ü§™ divised like:</p>
<ul>
<li>3 Namespaces</li>
<li>37 ClusterRole</li>
<li>14 ServiceAccount</li>
<li>17 ClusterRoleBinding</li>
<li>8 RBAC Role</li>
<li>6 RoleBinding</li>
<li>21 CRDs</li>
<li>32 ConfigMaps</li>
<li>15 Deployment</li>
<li>15 ReplicaSet</li>
<li>16 Services</li>
<li>20 Pods</li>
<li>2 StatefulSet</li>
<li>2 DaemonSet</li>
<li>1 HorizontalPodAutoscaler</li>
<li>&mldr;</li>
</ul>
</li>
<li>
<p>Before moving to the next step, we need to verify that all the pods are running:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl get pods --all-namespaces
</code></pre></td></tr></table>
</div>
</div><p>Now that your cluster has <strong>Knative</strong> installed, you‚Äôre ready to deploy an app. üòÅ</p>
</li>
</ol>
<h2 id=preparing-our-sample-application>PREPARING OUR SAMPLE APPLICATION<a hidden class=anchor aria-hidden=true href=#preparing-our-sample-application>#</a></h2>
<p>We will generate a new Spring Boot application with the Web dependency. We will create a new <code>RestController</code>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=nd>@RestController</span>
<span class=nd>@RequestMapping</span><span class=o>(</span><span class=s>&#34;/api&#34;</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>HelloController</span> <span class=o>{</span>

    <span class=nd>@GetMapping</span><span class=o>(</span><span class=s>&#34;/hello&#34;</span><span class=o>)</span>
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>sayHello</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=s>&#34;Hello Nebrass ! it&#39;s &#34;</span> <span class=o>+</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, I will package this beautiful application üòú in a Docker üê≥ container. I will be using the great <a href=https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin>Google Jib Maven</a> plugin. To do that I will add the plugin in the <code>build</code> section of the <code>pom.xml</code>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=nt>&lt;plugin&gt;</span>
    <span class=nt>&lt;groupId&gt;</span>com.google.cloud.tools<span class=nt>&lt;/groupId&gt;</span>
    <span class=nt>&lt;artifactId&gt;</span>jib-maven-plugin<span class=nt>&lt;/artifactId&gt;</span>
    <span class=nt>&lt;version&gt;</span>1.8.0<span class=nt>&lt;/version&gt;</span>
    <span class=nt>&lt;configuration&gt;</span>
        <span class=nt>&lt;to&gt;</span>
            <span class=nt>&lt;image&gt;</span>docker.io/nebrass/${project.artifactId}:${project.version}<span class=nt>&lt;/image&gt;</span>
            <span class=nt>&lt;credHelper&gt;</span>osxkeychain<span class=nt>&lt;/credHelper&gt;</span>
        <span class=nt>&lt;/to&gt;</span>
    <span class=nt>&lt;/configuration&gt;</span>
<span class=nt>&lt;/plugin&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>credHelper</code> section will tell the plugin to get my Docker Hub credentials from the Mac OS Keychain, where I stored them üòÅ for sure I will not be happy to share them üòú</p>
<p>Let&rsquo;s build the project now:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ mvn compile jib:build

This <span class=nb>command</span> will compile, build and push the container to **Docker Hub**. The **Jib** build log will look like:

<span class=o>[</span>INFO<span class=o>]</span> 
<span class=o>[</span>INFO<span class=o>]</span> --- jib-maven-plugin:1.8.0:build <span class=o>(</span>default-cli<span class=o>)</span> @ spring-knative-application ---
<span class=o>[</span>INFO<span class=o>]</span> 
<span class=o>[</span>INFO<span class=o>]</span> Containerizing application to nebrass/spring-knative-application:0.0.1-SNAPSHOT...
<span class=o>[</span>WARNING<span class=o>]</span> Base image <span class=s1>&#39;gcr.io/distroless/java:8&#39;</span> does not use a specific image digest - build may not be reproducible
<span class=o>[</span>INFO<span class=o>]</span> Using base image with digest: sha256:a13ac1ce516ec5e49ae9dfd3b8183e9e8328180a65757d454e594a9ce6d1e35d
<span class=o>[</span>INFO<span class=o>]</span> 
<span class=o>[</span>INFO<span class=o>]</span> Container entrypoint <span class=nb>set</span> to <span class=o>[</span>java, -cp, /app/resources:/app/classes:/app/libs/*, com.targa.labs.dev.knative.SpringKubelessApplication<span class=o>]</span>
<span class=o>[</span>INFO<span class=o>]</span> 
<span class=o>[</span>INFO<span class=o>]</span> Built and pushed image as nebrass/spring-knative-application:0.0.1-SNAPSHOT
<span class=o>[</span>INFO<span class=o>]</span> Executing tasks:
<span class=o>[</span>INFO<span class=o>]</span> <span class=o>[===========================</span>   <span class=o>]</span> 90,0% <span class=nb>complete</span>
<span class=o>[</span>INFO<span class=o>]</span> &gt; launching layer pushers
<span class=o>[</span>INFO<span class=o>]</span>
</code></pre></td></tr></table>
</div>
</div><p>Good ! But this is an over engineered solution for our <code>minikube</code> proof-of-concept. Instead, we can use the <code>minikube</code> local <strong>Docker</strong> registry. The <strong>Jib</strong> plugin configuration will look like:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=nt>&lt;plugin&gt;</span>
    <span class=nt>&lt;groupId&gt;</span>com.google.cloud.tools<span class=nt>&lt;/groupId&gt;</span>
    <span class=nt>&lt;artifactId&gt;</span>jib-maven-plugin<span class=nt>&lt;/artifactId&gt;</span>
    <span class=nt>&lt;version&gt;</span>1.8.0<span class=nt>&lt;/version&gt;</span>
    <span class=nt>&lt;configuration&gt;</span>
        <span class=nt>&lt;to&gt;</span>
            <span class=nt>&lt;image&gt;</span>nebrass/${project.artifactId}:${project.version}<span class=nt>&lt;/image&gt;</span>
        <span class=nt>&lt;/to&gt;</span>
    <span class=nt>&lt;/configuration&gt;</span>
<span class=nt>&lt;/plugin&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>Before building the <strong>Docker</strong> container, don&rsquo;t forget to map the environment to the <code>minikube</code> local environment:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>eval</span> <span class=k>$(</span>minikube docker-env<span class=k>)</span>

$ mvn compile jib:dockerBuild
</code></pre></td></tr></table>
</div>
</div><p>Now, the container will be built in the local <strong>Docker</strong> daemon and pushed into the <code>minikube</code> local registry.</p>
<p>Now, we need to create a <strong>Knative Service</strong> (aka <code>ksvc</code>). The <code>ksvc</code> definition file looks like:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>serving.knative.dev/v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>spring-knative-application</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w>        </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nebrass/spring-knative-application:0.0.1-SNAPSHOT</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>Now, let&rsquo;s create the <code>ksvc</code> resource from the this <code>ksvc.yaml</code> file:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl apply -f ksvc.yaml
</code></pre></td></tr></table>
</div>
</div><p>Now that our <strong>KService</strong> is created, <strong>Knative</strong> will perform the following steps:</p>
<ol>
<li>Create a new immutable revision for this version of the app.</li>
<li>Network programming to create a route, ingress, service, and load balancer for our app.</li>
<li>Automatically scale our pods up and down (including to zero active pods).</li>
</ol>
<p>To check the listing of the <strong>KServices</strong>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl get ksvc

NAME                         URL                                                     LATESTCREATED                      LATESTREADY                        READY   REASON
spring-knative-application   http://spring-knative-application.default.example.com   spring-knative-application-h4w27   spring-knative-application-h4w27   True
</code></pre></td></tr></table>
</div>
</div><p>The <strong>URL</strong> section is the one that interests us now: <a href=http://spring-knative-application.default.example.com>http://spring-knative-application.default.example.com</a></p>
<p>We will be using this value for consuming our <strong>KService.</strong> But before, we need to get the <strong>Istio Ingress Gateway</strong> IP address and port:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>IP_ADDRESS</span><span class=o>=</span><span class=k>$(</span>minikube ip<span class=k>)</span>:<span class=k>$(</span>kubectl get svc istio-ingressgateway <span class=se>\
</span><span class=se></span>        --namespace istio-system <span class=se>\
</span><span class=se></span>        --output <span class=s1>&#39;jsonpath={.spec.ports[?(@.port==80)].nodePort}&#39;</span><span class=k>)</span>
</code></pre></td></tr></table>
</div>
</div><p>In Knative, <strong>KService</strong> is reachable on:</p>
<div align=center>
<p><img loading=lazy src=../images/knative-ksvc-access-url-1024x255.webp alt="Knative KService access URL" title="Knative KService access URL">
Knative KService access path</p>
</div>
<p>We can for example access the <code>/api/hello</code> <strong>REST API</strong> on our <strong>spring-knative-application</strong> <code>ksvc</code> via <code>curl</code> :</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ curl -H <span class=s2>&#34;Host: spring-knative-application.default.example.com&#34;</span> <span class=nv>$IP_ADDRESS</span>/api/hello
</code></pre></td></tr></table>
</div>
</div><p>We can use also <a href=https://httpie.org/>httpie</a>, my preferred tool:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ http <span class=nv>$IP_ADDRESS</span>/api/hello <span class=s1>&#39;Host: spring-knative-application.default.example.com&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>The request parameters are:</p>
<ul>
<li><code>spring-knative-application.default.example.com</code>: is the URL of our <code>ksvc</code></li>
<li><code>$IP_ADDRESS</code>: is the <strong>Istio Ingress Gateway</strong> that we created in the previous step</li>
<li><code>/api/hello</code>: is the <strong>URI</strong> of our <strong>REST Controller</strong> that we created in our <strong>sample Spring Boot Application</strong></li>
</ul>
<p>Magically, we will get a response like :</p>
<p><code>Hello Nebrass ! it's 1574799175389</code></p>
<p>ü§©ü•≥ü§©ü•≥ WaaaaaYY ü§©ü•≥ü§©ü•≥</p>
<h2 id=behind-the-scenes---how-things-work->behind the scenes - how things work ?<a hidden class=anchor aria-hidden=true href=#behind-the-scenes---how-things-work->#</a></h2>
<p>Our application is served by the <strong>KNative Serving</strong> component (wow obviously üòÖ).. so let&rsquo;s go deep in the <strong>KNative Serving</strong>.</p>
<p>Let&rsquo;s start with some theories ü§ì This definitionsüëáüëá are grabbed from the <strong>official Knative documentation</strong> üëáüëá I made some modificatiosn</p>
<p><strong>Knative Serving</strong> defines a set of objects as Kubernetes <strong>Custom Resource Definitions</strong> (<strong>CRDs</strong>). These objects are used to define and control how your serverless workload behaves on the cluster:</p>
<ul>
<li><a href=https://github.com/knative/serving/blob/master/docs/spec/spec.md#service>Service</a>: The¬†<code>service.serving.knative.dev</code>¬†resource automatically manages the whole lifecycle of your workload. It controls the creation of other objects to ensure that your app has a <strong>route</strong>, a <strong>configuration</strong>, and a new <strong>revision</strong> for each update of the <strong>service</strong>. <strong>Service</strong> can be defined to always route traffic to the latest revision or to a pinned revision.</li>
<li><a href=https://github.com/knative/serving/blob/master/docs/spec/spec.md#route>Route</a>: The¬†<code>route.serving.knative.dev</code> resource maps a network endpoint to one or more <strong>revisions</strong>. You can manage the traffic in several ways, including fractional traffic and named <strong>Routes</strong>.</li>
<li><a href=https://github.com/knative/serving/blob/master/docs/spec/spec.md#configuration>Configuration</a>: The¬†<code>configuration.serving.knative.dev</code> resource maintains the desired state for your <strong>deployment</strong>. It provides a clean separation between code and configuration and follows the <em>12Factor App methodology</em>. <strong>Modifying a configuration creates a new revision</strong>. This is a very big point in <strong>KNative</strong>: <strong>REVISIONS ARE IMMUTABLE</strong>.</li>
<li><a href=https://github.com/knative/serving/blob/master/docs/spec/spec.md#revision>Revision</a>: The¬†<code>revision.serving.knative.dev</code> resource is a point-in-time snapshot of the code and configuration for each modification made to the workload. <strong>AGAIN: Revisions are immutable objects</strong> and can be retained for as long as useful. <strong>Knative Serving Revisions</strong> can be automatically scaled up and down according to incoming traffic.</li>
</ul>
<div align=center>
<p><img loading=lazy src=../images/object_model.webp alt="Knative Serving diagram">
Knative Serving diagram</p>
</div>
<p>This is the theory, but what&rsquo;s happening in our case ? üòÅ</p>
<p>The <strong>Knative Serving</strong> diagram of our use case his:</p>
<div align=center>
<p><img loading=lazy src=../images/knative-serving-ecosystem.webp alt="The Knative Serving Ecosystem for our use case" title="The Knative Serving Ecosystem for our use case">
The Knative Serving Ecosystem for our use case</p>
</div>
<p>What&rsquo;s this <strong>Autoscaler</strong> and <strong>Activator</strong>? üò±üò±</p>
<p>The <strong>Autoscaler & Activator</strong> are the two main components used by <strong>Knative</strong> to:</p>
<ul>
<li>handle elasticity of <strong>Pods</strong> to handle the high load of requests</li>
<li>scale down to zero when there is not active request üòÅ Don&rsquo;t forget, the idea behind the Serverless is to have no active resource in the IDLE status ü§ë</li>
</ul>
<p>The <strong>Autoscaler & Activator</strong> appear in the cluster as <strong>Pods</strong> running in the <code>knative-serving</code> <strong>namespace</strong>:</p>
<ul>
<li>The <strong>Autoscaler</strong> collects information about the number of concurrent requests to a <strong>Revision</strong>, through a container called the <code>queue-proxy</code> running inside the <strong>Revision‚Äôs Pod</strong> that already runs an other container called <code>user-provided</code> which is our <code>spring-knative-application</code> image. The <strong>Autoscaler</strong>, based on the <strong>number of requests</strong>, will <strong>increase</strong> or <strong>decrease</strong> the <strong>number of desired replicas</strong> in the <strong>Revision</strong> related <strong>Deployment</strong>.</li>
<li>The <strong>Activator</strong> is a component that receives all the traffic coming to the <strong>IDLE Revisions</strong>. When the <strong>Activator</strong> receives a request, it¬†changes the <strong>Revision</strong> state to <strong>Active</strong>, which lets the <strong>Revision Pods</strong> receive the requests.</li>
</ul>
<h2 id=playing-with-logs-metrics-and-traces-on-knative>Playing with Logs, metrics and traces on Knative<a hidden class=anchor aria-hidden=true href=#playing-with-logs-metrics-and-traces-on-knative>#</a></h2>
<h3 id=knative-logs>Knative logs<a hidden class=anchor aria-hidden=true href=#knative-logs>#</a></h3>
<p>In the KNative world, we have a (very) common Kubernetes logging pattern offered by the EFK brothers üòÅ no, seriously, no it&rsquo;s the EFK Band ü§©</p>
<ul>
<li><strong>Elasticsearch</strong> is a distributed, <em>RESTful</em> search and analytics engine.</li>
<li><strong>Fluentd</strong> is an <em>Logs</em> collector - alternative for <strong>Logstash</strong> and more suitable for <em>Containers</em>.</li>
<li><strong>Kibana</strong> most used <strong>Elasticsearch</strong> data visualization engine.</li>
</ul>
<p>Cool ! But we need to enable the <strong>EFK Logging</strong> in our <strong>KNative</strong> cluster: To do that we need to some configuration and some installations.</p>
<ol>
<li>
<p>We need to edit the <code>config-observability</code> <strong>ConfigMap</strong> stored in the <code>knative-serving</code> <strong>Namespace</strong>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl edit cm -n knative-serving config-observability
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Now, under the <code>data</code> section add this entry:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=err>logging.request-log-template:</span> <span class=err>&#39;</span><span class=p>{</span><span class=nt>&#34;httpRequest&#34;</span><span class=p>:</span> <span class=p>{</span><span class=nt>&#34;requestMethod&#34;</span><span class=p>:</span> <span class=s2>&#34;{{.Request.Method}}&#34;</span><span class=p>,</span>
    <span class=nt>&#34;requestUrl&#34;</span><span class=p>:</span> <span class=s2>&#34;{{js .Request.RequestURI}}&#34;</span><span class=p>,</span> <span class=nt>&#34;requestSize&#34;</span><span class=p>:</span> <span class=s2>&#34;{{.Request.ContentLength}}&#34;</span><span class=p>,</span>
    <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=p>{</span><span class=err>{.Response.Code</span><span class=p>}},</span> <span class=nt>&#34;responseSize&#34;</span><span class=p>:</span> <span class=s2>&#34;{{.Response.Size}}&#34;</span><span class=p>,</span> <span class=nt>&#34;userAgent&#34;</span><span class=p>:</span>
    <span class=s2>&#34;{{js .Request.UserAgent}}&#34;</span><span class=p>,</span> <span class=nt>&#34;remoteIp&#34;</span><span class=p>:</span> <span class=s2>&#34;{{js .Request.RemoteAddr}}&#34;</span><span class=p>,</span> <span class=nt>&#34;serverIp&#34;</span><span class=p>:</span>
    <span class=s2>&#34;{{.Revision.PodIP}}&#34;</span><span class=p>,</span> <span class=nt>&#34;referer&#34;</span><span class=p>:</span> <span class=s2>&#34;{{js .Request.Referer}}&#34;</span><span class=p>,</span> <span class=nt>&#34;latency&#34;</span><span class=p>:</span> <span class=s2>&#34;{{.Response.Latency}}s&#34;</span><span class=p>,</span>
    <span class=nt>&#34;protocol&#34;</span><span class=p>:</span> <span class=s2>&#34;{{.Request.Proto}}&#34;</span><span class=p>}</span><span class=err>,</span> <span class=s2>&#34;traceId&#34;</span><span class=err>:</span> <span class=s2>&#34;{{index .Request.Header &#34;</span><span class=err>X-B</span><span class=mi>3</span><span class=err>-Traceid</span><span class=s2>&#34;}}&#34;</span><span class=err>}&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>Be careful about the spaces, the <strong>ConfigMap</strong> will look like:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>data</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=nn>...</span><span class=w>
</span><span class=w>  </span><span class=nt>logging.request-log-template</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;{&#34;httpRequest&#34;: {&#34;requestMethod&#34;: &#34;{{.Request.Method}}&#34;,
</span><span class=s1>    &#34;requestUrl&#34;: &#34;{{js .Request.RequestURI}}&#34;, &#34;requestSize&#34;: &#34;{{.Request.ContentLength}}&#34;,
</span><span class=s1>    &#34;status&#34;: {{.Response.Code}}, &#34;responseSize&#34;: &#34;{{.Response.Size}}&#34;, &#34;userAgent&#34;:
</span><span class=s1>    &#34;{{js .Request.UserAgent}}&#34;, &#34;remoteIp&#34;: &#34;{{js .Request.RemoteAddr}}&#34;, &#34;serverIp&#34;:
</span><span class=s1>    &#34;{{.Revision.PodIP}}&#34;, &#34;referer&#34;: &#34;{{js .Request.Referer}}&#34;, &#34;latency&#34;: &#34;{{.Response.Latency}}s&#34;,
</span><span class=s1>    &#34;protocol&#34;: &#34;{{.Request.Proto}}&#34;}, &#34;traceId&#34;: &#34;{{index .Request.Header &#34;X-B3-Traceid&#34;}}&#34;}&#39;</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ConfigMap</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>annotations</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>kubectl.kubernetes.io/last-applied-configuration</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span><span class=sd>      </span><span class=w>      </span>{<span class=s2>&#34;apiVersion&#34;</span><span class=p>:</span><span class=s2>&#34;v1&#34;</span><span class=p>,</span><span class=s2>&#34;data&#34;</span><span class=p>:</span>{<span class=s2>&#34;_example&#34;</span><span class=p>:</span><span class=s2>&#34;...
</span><span class=s2>  creationTimestamp: &#34;</span><span class=ld>2019-11-27T13:53:51Z</span><span class=s2>&#34;
</span><span class=s2>  labels:
</span><span class=s2>    serving.knative.dev/release: v0.10.0
</span><span class=s2>  name: config-observability
</span><span class=s2>  namespace: knative-serving
</span><span class=s2>  resourceVersion: &#34;</span><span class=m>5058</span><span class=l>&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>selfLink</span><span class=p>:</span><span class=w> </span><span class=l>/api/v1/namespaces/knative-serving/configmaps/config-observability</span><span class=w>
</span><span class=w>  </span><span class=nt>uid</span><span class=p>:</span><span class=w> </span><span class=l>57a86288-111d-11ea-ba80-2659da8acb87</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Install the <strong>ELK Stack</strong>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl apply --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring-logs-elasticsearch.yaml
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Before going to the next steps, verify that all the pods are running:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl get pods --namespace knative-monitoring --watch
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>We need to to ensure that the <strong>Fluentd DaemonSet</strong> runs on all our nodes via labeling the nodes with the <code>beta.kubernetes.io/fluentd-ds-ready=true</code>¬†label:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl label nodes --all beta.kubernetes.io/fluentd-ds-ready<span class=o>=</span><span class=s2>&#34;true&#34;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Run the following command to ensure that the <code>fluentd-ds</code> <strong>DaemonSet</strong> is ready on at least one node:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl get daemonset fluentd-ds --namespace knative-monitoring --watch
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Now, we will start a local <strong>Kubernetes</strong> proxy:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl proxy
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Next, access the <strong>Kibana</strong> via the URL: <a href=http://localhost:8001/api/v1/namespaces/knative-monitoring/services/kibana-logging/proxy/app/kibana>http://localhost:8001/api/v1/namespaces/knative-monitoring/services/kibana-logging/proxy/app/kibana</a></p>
</li>
<li>
<p>Now, the first step is the configure an index pattern:</p>
<ul>
<li><strong>Index pattern:</strong> <code>logstash-*</code></li>
<li><strong>Time Filter field name:</strong> <code>@timestamp</code></li>
</ul>
<div align=center>
<p><img loading=lazy src=../images/knative-kibana-create-index-pattern.webp alt="Kibana - Create index pattern" title="Kibana - Create index pattern">
Kibana - Create index pattern</p>
</div>
</li>
<li>
<p>Now, click on the <strong>Discover</strong> menu, and in the search menu, we will enter the name of our <strong>KNative Service</strong>: <code>spring-knative-application</code></p>
<div align=center>
<p><img loading=lazy src=../images/knative-kibana-search.webp alt="Kibana - Searching KNative Service logging" title="Kibana - Searching KNative Service logging">
Kibana - Searching KNative Service logging</p>
</div>
<p>Have fun ! ü•≥üòçü§©</p>
</li>
</ol>
<h3 id=knative-metrics>Knative metrics<a hidden class=anchor aria-hidden=true href=#knative-metrics>#</a></h3>
<p>On <strong>KNative</strong>, we access metrics through the <a href=https://grafana.com/>Grafana UI</a>, which is the visualization tool for <a href=https://prometheus.io/>Prometheus</a>.</p>
<p>‚ö†Ô∏è If you are not used to <strong>Grafana</strong> and <strong>Prometheus</strong>, I <a href="https://www.youtube.com/watch?v=bErGEHf6GCc&list=PLpbcUe4chE7-HuslXKj1MB10ncorfzEGa">highly recommend this great free course</a> üòé Nowadays, mastering <strong>Grafana</strong> and <strong>Prometheus</strong> is a highly recommended skill for any <strong>Kubernetes</strong> professional.</p>
<p><a href="https://www.youtube.com/watch?v=bErGEHf6GCc&list=PLpbcUe4chE7-HuslXKj1MB10ncorfzEGa">https://www.youtube.com/watch?v=bErGEHf6GCc&list=PLpbcUe4chE7-HuslXKj1MB10ncorfzEGa</a></p>
<p>To open the <strong>KNative</strong>¬†<strong>Grafana UI</strong>, enter the following command:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl port-forward --namespace knative-monitoring <span class=se>\
</span><span class=se></span>    <span class=k>$(</span>kubectl get pods --namespace knative-monitoring <span class=se>\
</span><span class=se></span>    --selector<span class=o>=</span><span class=nv>app</span><span class=o>=</span>grafana <span class=se>\
</span><span class=se></span>    --output<span class=o>=</span><span class=nv>jsonpath</span><span class=o>=</span><span class=s2>&#34;{.items..metadata.name}&#34;</span><span class=k>)</span> <span class=m>3000</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, the <strong>Grafana UI</strong> is reachable via the URL: <a href=http://localhost:3000>http://localhost:3000</a>:</p>
<div align=center>
<p><img loading=lazy src=../images/knative-grafana-ui-1024x669.webp alt="Grafana UI: Knative Serving - Control Plane Efficiency dashboard" title="Grafana UI: Knative Serving - Control Plane Efficiency dashboard">
Grafana UI: Knative Serving - Control Plane Efficiency dashboard</p>
</div>
<p>The following dashboards are pre-installed with <strong>KNative</strong> <strong>Serving</strong>:</p>
<ul>
<li><strong>Revision HTTP Requests:</strong>¬†HTTP request count, latency, and size metrics per revision and per configuration</li>
<li><strong>Nodes:</strong>¬†CPU, memory, network, and disk metrics at node level</li>
<li><strong>Pods:</strong>¬†CPU, memory, and network metrics at pod level</li>
<li><strong>Deployment:</strong>¬†CPU, memory, and network metrics aggregated at deployment level</li>
<li><strong>Istio, Mixer and Pilot:</strong>¬†Detailed Istio mesh, Mixer, and Pilot metrics</li>
<li><strong>Kubernetes:</strong>¬†Dashboards giving insights into cluster health, deployments, and capacity usage</li>
</ul>
<p>If you are used to play with <strong>Prometheus</strong>, keep calm, you will find always your toy. To access <strong>Prometheus</strong>, run this command:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl port-forward -n knative-monitoring <span class=se>\
</span><span class=se></span>    <span class=k>$(</span>kubectl get pods -n knative-monitoring <span class=se>\
</span><span class=se></span>    --selector<span class=o>=</span><span class=nv>app</span><span class=o>=</span>prometheus <span class=se>\
</span><span class=se></span>    --output<span class=o>=</span><span class=nv>jsonpath</span><span class=o>=</span><span class=s2>&#34;{.items[0].metadata.name}&#34;</span><span class=k>)</span> <span class=m>9090</span>
</code></pre></td></tr></table>
</div>
</div><p>Next, access the <strong>Prometheus</strong> <strong>UI</strong> via the URL: <a href=http://localhost:9090>http://localhost:9090</a></p>
<div align=center>
<p><img loading=lazy src=../images/knative-prometheus-ui.webp alt="Prometheus UI" title="Prometheus UI">
Prometheus UI: sample <code>http_request_duration_microseconds</code>¬†graph</p>
</div>
<p>Enjoy ! ü•≥</p>
<h3 id=knative-request-tracing>Knative Request Tracing<a hidden class=anchor aria-hidden=true href=#knative-request-tracing>#</a></h3>
<p>We need to enable the support of <strong>Zipkin</strong> - I will be using <strong>Zipkin</strong> with in-memory database:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl apply --filename https://github.com/knative/serving/releases/download/v0.10.0/monitoring-tracing-zipkin-in-mem.yaml
</code></pre></td></tr></table>
</div>
</div><p>Next, before accessing the <strong>Zipkin UI</strong>, start local proxy:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ kubectl proxy
</code></pre></td></tr></table>
</div>
</div><p>Next, access the <strong>Zipkin UI</strong> via the URL: <a href=http://localhost:8001/api/v1/namespaces/istio-system/services/zipkin:9411/proxy/zipkin/>http://localhost:8001/api/v1/namespaces/istio-system/services/zipkin:9411/proxy/zipkin/</a></p>
<p>Now, click &ldquo;<strong>Find Traces</strong>&rdquo; to see the latest traces.</p>
<div align=center>
<p><img loading=lazy src=../images/knative-ksvc-zipkin-traces-1024x694.webp alt="Zipkin UI: KNative ksvc requests traces" title="Zipkin UI: KNative ksvc requests traces">
Zipkin UI: KNative <code>ksvc</code> requests traces</p>
</div>
<p>To load the <strong>requests traces</strong> on our <strong>KService</strong>, just choose:</p>
<ul>
<li><strong>istio-ingressgateway</strong> as <strong>Service Name</strong></li>
<li><strong>spring-knative-application-something</strong> as <strong>Span Name üëâ</strong> which is the only instance of our <strong>KNative</strong>, in case of high load you will find many instances of our <code>ksvc</code></li>
</ul>
<p>Click <strong>Find Traces</strong> to load all the gathered traces.</p>
<p>If you check the loaded traces, you can notice that the <strong>first request took 4 seconds</strong> to be handled, not like <strong>all the others that took only some milliseconds only</strong>. These traces can demonstrate the heavy cost of the first request. üòÅ</p>
<h2 id=where-is-the-knative-eventing-->Where is The knative eventing ? üòÅ<a hidden class=anchor aria-hidden=true href=#where-is-the-knative-eventing-->#</a></h2>
<p>COMING SOON !</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Playing with Serverless in Kubernetes with Knative on twitter" href="https://twitter.com/intent/tweet/?text=Playing%20with%20Serverless%20in%20Kubernetes%20with%20Knative&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Playing with Serverless in Kubernetes with Knative on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f&title=Playing%20with%20Serverless%20in%20Kubernetes%20with%20Knative&summary=Playing%20with%20Serverless%20in%20Kubernetes%20with%20Knative&source=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Playing with Serverless in Kubernetes with Knative on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f&title=Playing%20with%20Serverless%20in%20Kubernetes%20with%20Knative"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Playing with Serverless in Kubernetes with Knative on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Playing with Serverless in Kubernetes with Knative on whatsapp" href="https://api.whatsapp.com/send?text=Playing%20with%20Serverless%20in%20Kubernetes%20with%20Knative%20-%20https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Playing with Serverless in Kubernetes with Knative on telegram" href="https://telegram.me/share/url?text=Playing%20with%20Serverless%20in%20Kubernetes%20with%20Knative&url=https%3a%2f%2fblog.nebrass.fr%2fplaying-with-serverless-in-kubernetes-with-knative%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.nebrass.fr>Nebrass Homepage</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
</body>
</html>